<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"ccm.js.html":{"id":"ccm.js.html","title":"Source: ccm.js","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Source: ccm.js /** * @overview * Core script of _ccmjs_ that is automatically loaded as soon as a component is integrated into a webpage. * The core script sets an object in the namespace [window.ccm]{@link ccm} that represents the loaded _ccmjs_ version * and defines the Custom Element &lt;code&gt;\\&lt;ccm-app\\&gt;&lt;/code&gt;. * @author Andr√© Kless &lt;andre.kless@web.de&gt; 2014-2020 * @license The MIT License (MIT) * @version latest (26.0.0) * @changes * version 26.0.0 (18.09.2020) * - removed unneeded namespace ccm.latest * - removed unneeded shortcut methods ccm.set and ccm.del * - loaded HTML is not automatically converted to JSON for better performance * - ccm.load.timeout moved to ccm.timeout * - added attribute 'async' for loading of resources via &lt;script&gt; * - removed property 'import' for resource objects * - renamed value 'data' to 'json' for 'method' property of a resource object * - added loading of xml regardless of the file extension * - loading of a subset of exported module members * - ccm.helper.html accepts functions that return a TemplateResult from lit-html * - each instance knows her children instances * (for older version changes see ccm-25.5.3.js) * @tutorial usage-of-components */ ( () =&gt; { /** * Contains the registered components within this _ccmjs_ version. * @memberOf ccm * @private * @type {Object.&lt;ccm.types.component_index, ccm.types.component_obj&gt;} */ const _components = {}; /** * for creating ccm datastores * @private * @constructor */ const Datastore = function () { /** * websocket communication callbacks * @type {Function[]} */ const callbacks = []; /** * own reference for inner functions * @type {ccm.Datastore} */ let that; /** * instance for user authentication * @type {Object} */ let user; /** * is called once after for the initialization and is then deleted * @returns {Promise} */ this.init = async () =&gt; { // remember own reference for inner functions that = this; // prepare ccm database in IndexedDB await prepareDB(); // prepare websocket connection await prepareRealtime(); // one-time call delete that.init; /** * prepares ccm database if data is managed in IndexedDB * @returns {Promise} */ async function prepareDB() { // data is not managed in IndexedDB? =&gt; abort if ( !that.name || that.url ) return; // open database await openDB(); // create object store await createStore(); /** * opens ccm database if not already open * @returns {Promise} */ function openDB() { return new Promise( resolve =&gt; db ? resolve() : indexedDB.open( 'ccm' ).onsuccess = function () { db = this.result; resolve(); } ); } /** * creates object store if not already exists * @returns {Promise} */ function createStore() { return new Promise( resolve =&gt; { // object store already exists? =&gt; abort if ( db.objectStoreNames.contains( that.name ) ) return resolve(); /** * current database version number * @type {number} */ let version = parseInt( localStorage.getItem( 'ccm' ) ); // no version number? =&gt; start with 1 if ( !version ) version = 1; // close database db.close(); /** * request for reopening database * @type {Object} */ const request = indexedDB.open( 'ccm', version + 1 ); // set callback for event when update is needed request.onupgradeneeded = function () { // remember ccm database object db = this.result; // remember new database version number in local storage localStorage.setItem( 'ccm', db.version ); // create new object store db.createObjectStore( that.name, { keyPath: 'key' } ); }; request.onsuccess = resolve; } ); } } /** * prepares the realtime functionality * @returns {Promise} */ function prepareRealtime() { return new Promise( resolve =&gt; { // is no ccm realtime datastore? =&gt; abort if ( !that.url || that.url.indexOf( 'ws' ) !== 0 ) return resolve(); // no change callback and not a standalone datastore? =&gt; set default change callback: restart parent if ( !that.onchange &amp;&amp; that.parent ) that.onchange = that.parent.start; // prepare initial message let message = [ that.db, that.name ]; if ( that.dataset ) { if ( !Array.isArray( that.dataset ) ) that.dataset = [ that.dataset ]; message = message.concat( that.dataset ); } // connect to server that.socket = new WebSocket( that.url, 'ccm-cloud' ); // set server notification callback that.socket.onmessage = message =&gt; { // parse server message to JSON const {callback,data} = ccm.helper.parse( message.data ); // own request? =&gt; perform callback if ( callback ) { callbacks[ callback ]( data ); delete callbacks[ callback ]; } // notification about changed data from other client? =&gt; perform change callback else that.onchange &amp;&amp; that.onchange( data ); }; // send initial message that.socket.onopen = () =&gt; { that.socket.send( message ); resolve(); }; } ); } }; /** clears local cache */ this.clear = () =&gt; that.local = {}; /** * returns datastore source information * @returns {Object} */ this.source = () =&gt; { return { name: that.name, url: that.url, db: that.db } }; /** * requests one or more datasets * @param {ccm.types.key|Object} [key_or_query={}] - dataset key or query (default: query all datasets) * @returns {Promise} */ this.get = ( key_or_query={} ) =&gt; new Promise( ( resolve, reject ) =&gt; { // no manipulation of passed original parameter (avoids unwanted side effects) key_or_query = ccm.helper.clone( key_or_query ); // invalid key? =&gt; abort if ( !ccm.helper.isObject( key_or_query ) &amp;&amp; !ccm.helper.isKey( key_or_query ) ) reject( new Error( 'invalid dataset key: ' + key_or_query ) ); // detect managed data level that.url ? serverDB() : ( that.name ? clientDB() : localCache() ); /** requests dataset(s) from local cache */ function localCache() { // get local dataset(s) from local cache resolve( ccm.helper.clone( ccm.helper.isObject( key_or_query ) ? runQuery( key_or_query ) : that.local[ key_or_query ] ) ); /** * finds datasets in local cache by query * @param {Object} query * @returns {ccm.types.dataset[]} */ function runQuery( query ) { const results = []; for ( const key in that.local ) ccm.helper.isSubset( query, that.local[ key ] ) &amp;&amp; results.push( that.local[ key ] ); return results; } } /** requests dataset(s) from client-side database */ function clientDB() { const store = getStore(); const request = ccm.helper.isObject( key_or_query ) ? store.getAll() : store.get( key_or_query ); request.onsuccess = event =&gt; resolve( event.target.result || null ); request.onerror = event =&gt; reject( event.target.errorCode ); } /** requests dataset(s) from server-side database */ function serverDB() { ( that.socket ? useWebsocket : useHttp )( prepareParams( { get: key_or_query } ) ).then( resolve ).catch( error =&gt; checkError( error, reject ) ); } } ); /** * creates or updates a dataset * @param {Object} priodata - priority data * @returns {Promise} */ this.set = priodata =&gt; new Promise( ( resolve, reject ) =&gt; { // no manipulation of passed original parameter (avoids unwanted side effects) priodata = ccm.helper.toJSON( priodata ); // priority data has no key? =&gt; generate unique key if ( !priodata.key ) priodata.key = ccm.helper.generateKey(); // priority data contains invalid key? =&gt; abort if ( !ccm.helper.isKey( priodata.key ) &amp;&amp; !ccm.helper.isObject( priodata.key ) ) reject( new Error( 'invalid dataset key: ' + priodata.key ) ); // detect managed data level that.url ? serverDB() : ( that.name ? clientDB() : localCache() ); /** creates/updates dataset in local cache */ async function localCache() { // dataset already exists? =&gt; update if ( that.local[ priodata.key ] ) that.local[ priodata.key ] = await ccm.helper.integrate( priodata, that.local[ priodata.key ] ); // dataset not exists? =&gt; create else that.local[ priodata.key ] = priodata; resolve( priodata.key ); } /** creates/updates dataset in client-side database */ function clientDB() { const request = getStore().put( priodata ); request.onsuccess = event =&gt; event.target.result.toString() === priodata.key.toString() ? resolve( event.target.result ) : reject( event.target.result ); request.onerror = event =&gt; reject( event.target.errorCode ); } /** creates/updates dataset in server-side database */ function serverDB() { ( that.socket ? useWebsocket : useHttp )( prepareParams( { set: priodata } ) ).then( response =&gt; ( ccm.helper.isObject( priodata.key ) || response.toString() === priodata.key.toString() ? resolve : reject )( response ) ).catch( error =&gt; checkError( error, reject ) ); } } ); /** * deletes a dataset * @param {ccm.types.key} key - dataset key * @returns {Promise} */ this.del = key =&gt; new Promise( ( resolve, reject ) =&gt; { // invalid key? =&gt; abort if ( !ccm.helper.isKey( key ) ) reject( new Error( 'invalid dataset key: ' + key ) ); // detect managed data level that.url ? serverDB() : ( that.name ? clientDB() : localCache() ); /** deletes dataset in local cache */ function localCache() { delete that.local[ key ]; resolve( true ); } /** deletes dataset in client-side database */ function clientDB() { const request = getStore().delete( key ); request.onsuccess = event =&gt; event.target.result === undefined ? resolve( true ) : reject( event.target.result ); request.onerror = event =&gt; reject( event.target.errorCode ); } /** deletes dataset in server-side database */ function serverDB() { ( that.socket ? useWebsocket : useHttp )( prepareParams( { del: key } ) ).then( response =&gt; ( response === true ? resolve : reject )( response ) ).catch( error =&gt; checkError( error, reject ) ); } } ); /** * counts number of stored datasets * @param {Object} [query] - count how many stored datasets match the query (not supported for IndexedDB) * @returns {Promise&lt;number&gt;} */ this.count = query =&gt; new Promise( ( resolve, reject ) =&gt; { // detect managed data level that.url ? serverDB() : ( that.name ? clientDB() : localCache() ); function localCache() { resolve( query ? that.get( query ).then( datasets =&gt; datasets.length ) : Object.keys( that.local ).length ); } function clientDB() { const request = getStore().count(); request.onsuccess = event =&gt; ( !isNaN( event.target.result ) ? resolve : reject )( event.target.result ); request.onerror = event =&gt; reject( event.target.errorCode ); } function serverDB() { ( that.socket ? useWebsocket : useHttp )( prepareParams( query ? { count: query } : {} ) ).then( response =&gt; ( !isNaN( response ) ? resolve( parseInt( response ) ) : reject( response ) ) ).catch( error =&gt; checkError( error, reject ) ); } } ); /** * gets object store from IndexedDB * @returns {Object} */ function getStore() { return db.transaction( [ that.name ], 'readwrite' ).objectStore( that.name ); } /** * prepares data to be sent to server * @param {Object} [params] - data to be sent to server * @returns {Object} prepared data */ function prepareParams( params = {} ) { if ( that.db ) params.db = that.db; params.store = that.name; user = ccm.context.find( that, 'user' ); if ( user &amp;&amp; user.isLoggedIn() ) { params.realm = user.getRealm(); params.token = user.data().token; } return params; } /** * checks server error * @param error * @param reject * @returns {Promise&lt;void&gt;} */ async function checkError( error, reject ) { // token has expired? =&gt; user must login again and app restarts if ( error &amp;&amp; ( error === 401 || error.data &amp;&amp; error.data.status === 401 ) &amp;&amp; user ) { try { await user.logout(); await user.login(); await ccm.context.root( user ).start(); } catch ( e ) { await ccm.context.root( user ).start(); } } else reject( error ); } /** * sends data to server interface via websocket connection * @param {Object} params - data to be sent to server * @returns {Promise} */ function useWebsocket( params ) { return new Promise( ( resolve, reject ) =&gt; { const key = ccm.helper.generateKey(); callbacks[ key ] = result =&gt; Number.isInteger( result ) ? checkError( result, reject ) : resolve( result ); params.callback = key; that.socket.send( ccm.helper.stringify( params ) ); } ); } /** * sends data to server interface via HTTP request * @param {Object} params - data to be sent to server * @returns {Promise} */ function useHttp( params ) { return ccm.load( { url: that.url, params: params, method: that.method } ); } }; /** * ccm database in IndexedDB * @type {Object} */ let db; // set global namespace if ( !window.ccm ) window.ccm = { /** * @description * JSONP callbacks for cross domain data exchanges via {@link ccm.load} are temporarily stored here (is always emptied directly). * This global namespace &lt;code&gt;ccm.callbacks&lt;/code&gt; is also used for dynamic loading of JavaScript modules. * The namespace is only used internally by _ccmjs_ and should not used by component developers. * @memberOf ccm * @type {Object.&lt;string,function&gt;} * @tutorial loading-of-resources */ callbacks: {}, /** * @description * Result data of loaded JavaScript files via {@link ccm.load} are temporarily stored here (is always emptied directly). * The namespace is only used internally by _ccmjs_ and should not used by component developers. * @memberOf ccm * @type {Object} * @tutorial loading-of-resources */ files: {} }; /** * Everything around _ccmjs_ is capsuled in the single global namespace &lt;code&gt;window.ccm&lt;/code&gt;. * The namespace contains the latest version of _ccmjs_ that has been loaded so far within the webpage. * In the webpage a _ccmjs_ version is represented as a JavaScript object. * The object provides methods for [using components]{@tutorial usage-of-components}, [loading of resources]{@tutorial loading-of-resources} and [data management]{@tutorial data-management}. * For [backwards compatibility]{@tutorial backwards-compatibility} each _ccmjs_ version loaded on the webpage so far has its own inner namespace within &lt;code&gt;window.ccm&lt;/code&gt;. * This ensures that different versions of _ccmjs_ can be used without conflict within the same webpage. * @global * @namespace */ const ccm = { /** * @summary loads resources * @description * _ccmjs_ provides a service for asynchronous loading of resources. It could be used with the method &lt;code&gt;ccm.load&lt;/code&gt;. * You can load resources like HTML, CSS, Images, JavaScript, Modules, JSON and XML data on-demand and cross-domain. * On a single call several resources can be loaded at once. It can be flexibly controlled which resources are loaded in serial and which in parallel. * See {@tutorial loading-of-resources} to learn everything about this method. There are also more examples how to use it. * This method can be used to define dependencies to other resources in [instance configurations]{@link ccm.types.instance_config}. * @param {...(string|ccm.types.resource_obj)} resources - resources data * @returns {Promise&lt;*&gt;} * @tutorial loading-of-resources */ load: function () { /** * arguments of this ccm.load call * @type {Array} */ const args = [ ...arguments ]; /** * current ccm.load call * @type {ccm.types.action} */ const call = args.slice( 0 ); call.unshift( ccm.load ); /** * result(s) of this ccm.load call * @type {*} */ let results = []; /** * number of resources being loaded * @type {number} */ let counter = 1; /** * indicates whether loading of at least one resource failed * @type {boolean} */ let failed = false; return new Promise( ( resolve, reject ) =&gt; { // iterate over resources data =&gt; load resource(s) args.forEach( ( resource, i ) =&gt; { // increase number of resources being loaded counter++; // no manipulation of passed original parameters (avoids unwanted side effects) resource = ccm.helper.clone( resource ); // resource data is an array? =&gt; load resources serially if ( Array.isArray( resource ) ) { results[ i ] = []; serial( null ); return; } // has resource URL instead of resource data? =&gt; use resource data which contains only the URL information if ( !ccm.helper.isObject( resource ) ) resource = { url: resource }; /** * file extension from the URL of the resource * @type {string} */ const suffix = resource.url.split( '.' ).pop().split( '?' ).shift().split( '#' ).shift().toLowerCase(); // ensuring lowercase on HTTP method if ( resource.method ) resource.method = resource.method.toLowerCase(); // no given resource context or context is 'head'? =&gt; load resource in global &lt;head&gt; context (no Shadow DOM) if ( !resource.context || resource.context === 'head' ) resource.context = document.head; // given resource context is a ccm instance? =&gt; load resource in shadow root context of that instance if ( ccm.helper.isInstance( resource.context ) ) resource.context = resource.context.element.parentNode; /** * operation for loading resource * @type {Function} */ const operation = getOperation(); // timeout check let timeout; ccm.timeout &amp;&amp; window.setTimeout( () =&gt; timeout === undefined &amp;&amp; ( timeout = true ) &amp;&amp; error( 'timeout' ), ccm.timeout ); // start loading of resource operation(); /** * loads resources serially (recursive function) * @param {*} result - result of last serially loaded resource (is null on first call) */ function serial( result ) { // not the first call? =&gt; add result of last call to serially results if ( result !== null ) results[ i ].push( result ); // serially loading of resources completed? =&gt; finish serially loading and check if all resources of this ccm.load call are loaded if ( resource.length === 0 ) return check(); // load next resource serially (recursive call of ccm.load and this function) let next = resource.shift(); if ( !Array.isArray( next ) ) next = [ next ]; ccm.load.apply( null, next ).then( serial ).catch( serial ); // if next resource is an array, contained resources are loaded in parallel } /** * determines operation for loading resource * @returns {Function} */ function getOperation() { switch ( resource.type ) { case 'html': return loadHTML; case 'css': return loadCSS; case 'image': return loadImage; case 'js': return loadJS; case 'module': return loadModule; case 'json': return loadJSON; case 'xml': return loadXML; } switch ( suffix ) { case 'html': return loadHTML; case 'css': return loadCSS; case 'jpg': case 'jpeg': case 'gif': case 'png': case 'svg': case 'bmp': return loadImage; case 'js': return loadJS; case 'mjs': return loadModule; case 'xml': return loadXML; default: return loadJSON; } } /** loads a HTML file */ function loadHTML() { // load HTML as string via HTTP GET request resource.type = 'html'; resource.method = 'get'; loadJSON(); } /** loads (and executes) a CSS file */ function loadCSS() { // already exists in same context? =&gt; abort if ( resource.context.querySelector( 'link[rel=\"stylesheet\"][type=\"text/css\"][href=\"' + resource.url + '\"]' ) ) return success(); // load the CSS file via a &lt;link&gt; element let element = { tag: 'link', rel: 'stylesheet', type: 'text/css', href: resource.url }; if ( resource.attr ) element = Object.assign( element, resource.attr ); element = ccm.helper.html( element ); element.onload = success; element.onerror = event =&gt; { element.parentNode.removeChild( element ); error( element, event ); }; resource.context.appendChild( element ); } /** (pre)loads an image file */ function loadImage() { // (pre)load the image file via an image object const image = new Image(); image.onload = success; image.onerror = event =&gt; error( image, event ); image.src = resource.url; } /** loads (and executes) a JavaScript file */ function loadJS() { /** * filename of JavaScript file (without '.min') * @type {string} */ const filename = resource.url.split( '/' ).pop().split( '?' ).shift().replace( '.min.', '.' ); // mark JavaScript file as loading window.ccm.files[ filename ] = null; window.ccm.files[ '#' + filename ] = window.ccm.files[ '#' + filename ] ? window.ccm.files[ '#' + filename ] + 1 : 1; // load the JavaScript file via a &lt;script&gt; element let element = { tag: 'script', src: resource.url, async: true }; if ( resource.attr ) element = Object.assign( element, resource.attr ); element = ccm.helper.html( element ); element.onload = () =&gt; { /** * data globally stored by loaded JavaScript file * @type {*} */ const data = window.ccm.files[ filename ]; // remove stored data from global context if ( !--window.ccm.files[ '#' + filename ] ) { delete window.ccm.files[ filename ]; delete window.ccm.files[ '#' + filename ]; } // remove no more needed &lt;script&gt; element element.parentNode.removeChild( element ); // perform success callback data !== null ? successData( data ) : success(); }; element.onerror = event =&gt; { element.parentNode.removeChild( element ); error( element, event ); }; resource.context.appendChild( element ); } /** loads a JavaScript module */ function loadModule() { const callback = 'callback' + ccm.helper.generateKey(); window.ccm.callbacks[ callback ] = result =&gt; { element.parentNode.removeChild( element ); delete window.ccm.callbacks[ callback ]; successData( result ); }; let element = ccm.helper.html( { tag: 'script', type: 'module', async: true } ); if ( resource.attr ) element = Object.assign( element, resource.attr ); element.onerror = event =&gt; { element.parentNode.removeChild( element ); error( element, event ); }; const [ url, ...keys ] = resource.url.split( '#' ); const key = keys.join( ',' ); const query = keys.length === 1 ? `{${key} as result }` : `* as result`; const result = keys.length &gt; 1 ? `(({${key}}) =&gt; ({${key}}))(result)` : 'result'; element.text = `import ${query} from '${url}'; window.ccm.callbacks['${callback}'](${result})`; document.head.appendChild( element ); } /** loads JSON data */ function loadJSON() { // load data using desired method switch ( resource.method ) { case 'jsonp': jsonp(); break; case 'get': case 'post': case 'put': case 'delete': ajax(); break; case 'fetch': fetchAPI(); break; default: resource.method = 'post'; ajax(); } /** performs a data exchange via JSONP */ function jsonp() { // prepare callback function const callback = 'callback' + ccm.helper.generateKey(); if ( !resource.params ) resource.params = {}; resource.params.callback = 'window.ccm.callbacks.' + callback; window.ccm.callbacks[ callback ] = data =&gt; { element.parentNode.removeChild( element ); delete window.ccm.callbacks[ callback ]; successData( data ); }; // prepare &lt;script&gt; element for data exchange let element = { tag: 'script', src: buildURL( resource.url, resource.params ) }; if ( resource.attr ) element = Object.assign( element, resource.attr ); element = ccm.helper.html( element ); element.onerror = event =&gt; { element.parentNode.removeChild( element ); error( element, event ); }; element.src = element.src.replace( /&amp;amp;/g, '&amp;' ); // TODO: Why is this \"&amp;amp;\" happening in ccm.helper.html? // start data exchange resource.context.appendChild( element ); } /** performs a data exchange via AJAX request */ function ajax() { const request = new XMLHttpRequest(); request.open( resource.method, resource.method === 'get' &amp;&amp; resource.params ? buildURL( resource.url, resource.params ) : resource.url, true ); if ( resource.headers ) for ( const key in resource.headers ) { request.setRequestHeader( key, resource.headers[ key ] ); if ( key.toLowerCase() === 'authorization' ) request.withCredentials = true; } ( resource.method === 'post' || resource.method === 'put' ) &amp;&amp; request.setRequestHeader( 'Content-Type', 'application/json' ); request.onreadystatechange = () =&gt; { if ( request.readyState === 4 ) request.status &gt;= 200 &amp;&amp; request.status &lt; 300 ? successData( request.responseText ) : error( request ); }; request.send( resource.method === 'post' || resource.method === 'put' ? ccm.helper.stringify( resource.params ) : undefined ); } /** performs a data exchange via fetch API */ function fetchAPI() { if ( !resource.init ) resource.init = {}; if ( resource.params ) resource.init.method.toLowerCase() === 'post' ? resource.init.body = ccm.helper.stringify( resource.params) : resource.url = buildURL( resource.url, resource.params ); fetch( resource.url, resource.init ).then( response =&gt; response.text() ).then( successData ).catch( error ); } /** * adds HTTP parameters in URL * @param {string} url - URL * @param {Object} data - HTTP parameters * @returns {string} URL with added HTTP parameters */ function buildURL( url, data ) { if ( ccm.helper.isObject( data.json ) ) data.json = ccm.helper.stringify( data.json ); return data ? url + '?' + params( data ).slice( 0, -1 ) : url; function params( obj, prefix ) { let result = ''; for ( const i in obj ) { const key = prefix ? prefix + '[' + encodeURIComponent( i ) + ']' : encodeURIComponent( i ); if ( typeof( obj[ i ] ) === 'object' ) result += params( obj[ i ], key ); else result += key + '=' + encodeURIComponent( obj[ i ] ) + '&amp;'; } return result; } } } /** loads a XML file */ function loadXML() { if ( !resource.method ) resource.method = 'post'; const request = new XMLHttpRequest(); request.overrideMimeType( 'text/xml' ); request.onreadystatechange = () =&gt; { if ( request.readyState === 4 ) request.status === 200 ? successData( request.responseXML ) : error( request ); }; request.open( resource.method, resource.url, true ); request.send(); } /** * when a data exchange has been completed successfully * @param {*} data - received data */ function successData( data ) { // timeout already occurred? =&gt; abort (counter will not decrement) if ( checkTimeout() ) return; // received data is a JSON string? =&gt; parse it to JSON try { if ( typeof data !== 'object' ) data = ccm.helper.parse( data ); } catch ( e ) {} // received data is loaded HTML? =&gt; look for &lt;ccm-template&gt; tags if ( resource.type === 'html' ) { const regex = /&lt;ccm-template key=\"(\\w*?)\"&gt;([^]*?)&lt;\\/ccm-template&gt;/g; const result = {}; let array; while ( array = regex.exec( data ) ) result[ array[ 1 ] ] = array[ 2 ]; if ( Object.keys( result ).length ) data = result; } // add received data to results of ccm.load call and to cache results[ i ] = data; // perform success callback success(); } /** when a resource is loaded successfully */ function success() { // timeout already occurred? =&gt; abort (counter will not decrement) if ( checkTimeout() ) return; // is there no result value yet? =&gt; use URL as result if ( results[ i ] === undefined ) results[ i ] = resource.url; // check if all resources are loaded check(); } /** * checks if timeout already occurred * @returns {boolean} */ function checkTimeout() { return timeout ? ccm.helper.log( 'loading of ' + resource.url + ' succeeded after timeout (' + ccm.timeout + 'ms)' ) || true : timeout = false; } /** * when loading of a resource failed * @param {...*} data - relevant process data */ function error() { // loading of at least one resource failed failed = true; // create load error data results[ i ] = { error: new Error( 'loading of ' + resource.url + ' failed' ), // error object resource: resource, // resource data data: [ ...arguments ], // relevant process data call: call // ccm.load call }; if ( results[ i ].data.length &lt;= 1 ) results[ i ].data = results[ i ].data[ 0 ]; // check if all resources are loaded check(); } } ); // check if all resources are loaded (important if all resources are already loaded) check(); /** checks if all resources are loaded */ function check() { // still more loading resources left? =&gt; abort if ( --counter ) return; // only one result? =&gt; do not use an array if ( results.length === 1 ) results = results[ 0 ]; // finish this ccm.load call ( failed ? reject : resolve )( results ); } } ); }, /** * @summary registers a component * @description * Registers a component within this _ccmjs_ version. The returned [component object]{@link ccm.types.component_obj} can than be used for flexible [instance]{@link ccm.types.instance} creation. * This method can be used to define dependencies to other components in [instance configurations]{@link ccm.types.instance_config}. * After registration, the component is ready to use on the webpage. * If a URL to a component file is passed instead of a [component object]{@link ccm.types.component_obj}, the object is determined by loading this file. * If the component uses a different _ccmjs_ version, this version is loaded (if not already present) and then the component is registered in that _ccmjs_ version instead. * With the `config` parameter you can pass a default [instance configuration]{@link ccm.types.instance_config} that will be integrated with higher priority in the default [instance configuration]{@link ccm.types.instance_config} that is defined by the component. * The resulting default configuration applies for all [instances]{@link ccm.types.instance} that are created via the returned [component object]{@link ccm.types.component_obj}. * @param {ccm.types.component_obj|string} component - component object or URL of a component file * @param {ccm.types.instance_config} [config] - default configuration for instances that are created out of the component (check documentation of associated component to see which properties could be set) * @returns {Promise&lt;ccm.types.component_obj&gt;} cloned component object (the original cannot be reached from the outside for security reasons) * @example * const component_obj = await ccm.component( { * name: 'blank', * ccm: 'https://ccmjs.github.io/ccm/ccm.js', * Instance: function () { * this.start = async () =&gt; { * this.element.innerHTML = 'Hello, World!'; * }; * } * } ); * const instance = await component_obj.instance( { root: document.body } ); * await instance.start(); * @example * const component_obj = await ccm.component( * 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js' * ); * const instance = await component_obj.instance( { root: document.body } ); * await instance.start(); * @tutorial usage-of-components */ component: async ( component, config ) =&gt; { // get component object component = await getComponentObject(); // no component object? =&gt; throw error if ( !ccm.helper.isComponent( component ) ) throw new Error( 'invalid component object' ); // used ccmjs version could be set via config await changeVersion( component, config ); // load needed ccmjs version and remember version number const version = ( ccm.helper.isCore( component.ccm ) ? component.ccm : await ccm.helper.loadVersion( component.ccm ) ).version(); // component uses other ccmjs version? =&gt; register component via other ccmjs version (and considers backward compatibility) if ( version !== ccm.version() ) return new Promise( async resolve =&gt; { const result = await window.ccm[ version ].component( component, config, resolve ); result &amp;&amp; resolve( result ); } ); // set component index component.index = component.name + ( component.version ? '-' + component.version.join( '-' ) : '' ); // component not registered? =&gt; register component if ( !_components[ component.index ] ) { // register component _components[ component.index ] = component; // create global component namespaces ccm.components[ component.index ] = {}; component.instances = 0; // add ccm instance counter component.ccm = window.ccm[ version ]; // add ccmjs reference // initialize component component.ready &amp;&amp; await component.ready.call( component ); delete component.ready; // define HTML tag for component await defineCustomElement( component.index ); } // is registered =&gt; use already registered component object (security reasons) else component = _components[ component.index ]; // no manipulation of original registered component object (security reasons) component = ccm.helper.clone( component ); // set default instance configuration component.config = await prepareConfig( config, component.config ); // add functions for creating and starting ccm instances component.instance = async config =&gt; await ccm.instance( component, await prepareConfig( config, component.config ) ); component.start = async config =&gt; await ccm.start ( component, await prepareConfig( config, component.config ) ); return component; /** * gets component object * @returns {Promise} */ async function getComponentObject() { // component is given as string? (component index or URL) if ( typeof component === 'string' ) { /** * component index * @type {ccm.types.index} */ const index = component.endsWith( '.js' ) ? ccm.helper.convertComponentURL( component ).index : component; // already registered component? =&gt; use already registered component object if ( _components[ index ] ) return ccm.helper.clone( _components[ index ] ); // has component URL? =&gt; load component object if ( ccm.helper.regex( 'filename' ).test( component.split( '/' ).pop() ) ) { const response = await ccm.load( component ); response.url = component; return response; } // not registered and no URL? =&gt; throw error return new Error( 'invalid component index or URL: ' + component ); } // component is directly given as object return component; } }, /** * @summary registers a component and creates an instance out of it * @description * This method does the same as {@link ccm.component} with the difference that an [instance]{@link ccm.types.instance} is created directly from the component after the registration. * The created [instance]{@link ccm.types.instance} is returned as result. Whenever the start method of the [instance]{@link ccm.types.instance} is called, the [instance]{@link ccm.types.instance} begins to design the webpage area assigned to it. * This method can be used to define dependencies to other [instances]{@link ccm.types.instance} in [instance configurations]{@link ccm.types.instance_config}. * The given [instance configuration]{@link ccm.types.instance_config} will be integrated with higher priority in the default [instance configuration]{@link ccm.types.instance_config} that is defined by the component. * @param {ccm.types.component_obj|string} component - component object or URL of a component file * @param {Object} [config] - instance configuration (check documentation of associated component to see which properties could be set) * @returns {Promise&lt;ccm.types.instance&gt;} * @example * const instance = await ccm.instance( { * name: 'blank', * ccm: 'https://ccmjs.github.io/ccm/ccm.js', * Instance: function () { * this.start = async () =&gt; { * this.element.innerHTML = 'Hello, World!'; * }; * } * }, { root: document.body } ); * await instance.start(); * @example * const instance = await ccm.instance( * 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js', * { root: document.body } * ); * await instance.start(); * @tutorial usage-of-components */ instance: async ( component, config ) =&gt; { // has root element? =&gt; add loading icon if ( config &amp;&amp; config.root &amp;&amp; config.parent ) { config.root.innerHTML = ''; config.root.appendChild( ccm.helper.loading( config.parent ) ); } // get object of ccm component component = await ccm.component( component, { ccm: config &amp;&amp; config.ccm } ); config &amp;&amp; delete config.ccm; // prepare ccm instance configuration config = await prepareConfig( config, component.config ); // perform 'beforeCreation' callback config.beforeCreation &amp;&amp; await config.beforeCreation( config, ccm.helper.clone( component ) ); delete config.beforeCreation; // no component object? =&gt; abort if ( !ccm.helper.isComponent( component ) ) return component; // component uses other ccmjs version? =&gt; create instance via other ccmjs version (and considers backward compatibility) if ( component.ccm.version() !== ccm.version() ) return new Promise( async resolve =&gt; { const result = await window.ccm[ component.ccm.version() ].instance( component, config, resolve ); result &amp;&amp; resolve( result ); } ); /** * created and prepared ccm instance * @type {ccm.types.instance} */ let instance = createInstance(); // perform 'afterCreation' callback config.afterCreation &amp;&amp; await config.afterCreation( config, ccm.helper.clone( component ) ); delete config.afterCreation; // each instance knows his original config instance.config = ccm.helper.stringify( config ); // root element without DOM contact? =&gt; add root in &lt;head&gt; (resolving dependencies requires DOM contact) if ( !document.contains( instance.root ) ) { instance.root.position = document.createElement( 'div' ); if ( instance.root.parentNode ) instance.root.parentNode.replaceChild( instance.root.position, instance.root ); document.head.appendChild( instance.root ); } // solve ccm dependencies contained in config config = await ccm.helper.solveDependencies( config, instance ); // restore original root position if ( document.head.contains( instance.root ) ) { document.head.removeChild( instance.root ); if ( instance.root.position.parentNode ) instance.root.position.parentNode.replaceChild( instance.root, instance.root.position ); delete instance.root.placeholder; } // convert Light DOM to Element Node config.inner = ccm.helper.html( config.inner, undefined, { no_evaluation: true } ); // integrate config in created ccm instance Object.assign( instance, config ); // initialize created and dependent instances if ( !instance.parent || !instance.parent.init ) await initialize(); // perform 'onReady' callback instance.onReady &amp;&amp; await instance.onReady( instance ); delete instance.onReady; return instance; /** * creates and prepares a ccm instance out of component * @returns {ccm.types.instance} */ function createInstance() { /** * created ccm instance * @type {ccm.types.instance} */ const instance = new component.Instance(); // set ccm specific instance properties instance.ccm = component.ccm; // ccmjs reference instance.component = component; // set component reference instance.parent = config.parent; delete config.parent; // reference of parent ccm instance instance.children = {}; // reference to children instances instance.root = config.root; delete config.root; // instance root element instance.id = ++_components[ component.index ].instances; // instance ID instance.index = component.index + '-' + instance.id; // instance index (unique in hole website) setElement(); // set root and content element if ( !instance.init ) instance.init = async () =&gt; {}; // each instance must have a init method if ( instance.parent ) { if ( !instance.parent.children ) instance.parent.children = {}; instance.parent.children[ instance.index ] = instance; } // state of an instance can be influenced by HTML attributes of instance root element if ( instance.root.id === instance.index &amp;&amp; instance.root.parentNode &amp;&amp; instance.root.parentNode.tagName.indexOf( 'CCM-' ) === 0 ) watchAttributes(); return instance; /** sets root element with contained Shadow DOM and content element */ function setElement() { // root is keyword 'parent'? =&gt; use parent root and content element if ( instance.root === 'parent' &amp;&amp; instance.parent ) { instance.root = instance.parent.root; instance.element = instance.parent.element; return; } // root is a string? =&gt; use inner website area of the parent where HTML ID is equal to given string or component name (if root is keyword 'name') if ( typeof instance.root === 'string' ) instance.root = instance.parent.element.querySelector( '#' + ( instance.root === 'name' &amp;&amp; instance.parent ? component.name : instance.root ) ); /** * root element of ccm instance * @type {Element} */ const root = ccm.helper.html( { id: instance.index } ); // set root element if ( instance.root ) { instance.root.innerHTML = ''; instance.root.appendChild( root ); instance.root = root; } // handle Shadow DOM if ( !config.shadow ) config.shadow = 'closed'; if ( typeof config.shadow === 'string' &amp;&amp; config.shadow !== 'none' ) { instance.shadow = root.shadowRoot || root.attachShadow( { mode: config.shadow } ); delete config.shadow; } // set content element ( instance.shadow || root ).appendChild( instance.element = ccm.helper.html( { id: 'element' } ) ); // set observed responsive breakpoints for content element config.breakpoints !== false &amp;&amp; ccm.helper.responsive( instance.element, config.breakpoints, instance ); if ( !instance.root ) instance.root = root; // has start method? =&gt; add loading icon if ( instance.start ) { instance.element.innerHTML = ''; instance.element.appendChild( ccm.helper.loading( instance ) ); } } /** watches HTML attributes of instance root element */ function watchAttributes() { // instance has no update method? =&gt; set default update method if ( !instance.update ) instance.update = ( key, value ) =&gt; { switch ( key ) { case 'ccm': case 'component': case 'config': case 'element': case 'id': case 'index': case 'init': case 'onfinish': case 'parent': case 'ready': case 'root': case 'start': case 'update': break; case 'key': if ( ccm.helper.regex( 'json' ).test( value ) ) value = ccm.helper.parse( value ); if ( ccm.helper.isObject( value ) ) for ( const key in value ) if ( value.hasOwnProperty( key ) ) switch ( key ) { case 'ccm': case 'component': case 'dependency': case 'parent': case 'id': case 'index': case 'element': case 'root': case 'init': case 'ready': case 'start': case 'update': case 'key': break; default: instance[ key ] = value[ key ] } instance.start(); break; default: instance[ key ] = value; instance.start(); } }; // watch attributes const MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver; const observer = new MutationObserver( mutations =&gt; mutations.forEach( mutation =&gt; { if ( mutation.type !== 'attributes' ) return; const key = mutation.attributeName; const value = instance.root.parentNode.getAttribute( key ); instance.update( key, value ); } ) ); observer.observe( instance.root.parentNode, { attributes: true } ); } } /** * calls init and ready method of created and dependent ccm instances * @returns {Promise} */ function initialize() { return new Promise( resolve =&gt; { /** * founded ccm instances * @type {ccm.types.instance[]} */ const instances = [ instance ]; // find dependent ccm instances find( instance ); // call init methods of all founded ccm instances let i = 0; init(); /** * finds all ccm instances (breadth-first-order, recursive) * @param {Object|Array} obj - object/array that is searched */ function find( obj ) { /** * founded relevant inner objects/arrays (needed to get breath-first-order) * @type {Array.&lt;Object|Array&gt;} */ const relevant = []; // search object/array for ( const key in obj ) if ( obj.hasOwnProperty &amp;&amp; obj.hasOwnProperty( key ) ) { const value = obj[ key ]; // value is a ccm instance? (but not parent or proxy instance) =&gt; add to founded instances if ( ccm.helper.isInstance( value ) &amp;&amp; key !== 'parent' &amp;&amp; !ccm.helper.isProxy( value) ) { instances.push( value ); relevant.push( value ); } // value is an object/array? else if ( Array.isArray( value ) || ccm.helper.isObject( value ) ) { // not relevant object type? =&gt; skip if ( ccm.helper.isSpecialObject( value ) ) continue; // add value to relevant inner objects/arrays relevant.push( value ); } } // search relevant inner objects/arrays (recursive calls) relevant.map( find ); } /** calls init methods (forward) of all founded ccm instances (recursive, asynchron) */ function init() { // all init methods called? =&gt; call ready methods if ( i === instances.length ) return ready(); /** * first founded ccm instance with not called init method * @type {ccm.types.instance} */ const next = instances[ i++ ]; // call and delete init method and continue with next founded ccm instance (recursive call) next.init ? next.init().then( () =&gt; { delete next.init; init(); } ) : init(); } /** calls ready methods (backward) of all founded ccm instance (recursive, asynchron) */ function ready() { // all ready methods called? =&gt; perform callback if ( !instances.length ) return resolve(); /** * last founded ccm instance with not called ready method * @type {ccm.types.instance} */ const next = instances.pop(); // result has a ready function? =&gt; perform and delete ready function and check next result afterwards (recursive call) next.ready ? next.ready().then( () =&gt; { delete next.ready; ready(); } ) : ready(); // does the app have to be started directly? =&gt; do it if ( next._start ) { delete next._start; next.start(); } } } ); } }, /** * @ignore * @summary registers a _ccm_ component and creates a proxy instance out of it * @description Use this for lazy loading of a _ccm_ instance. The proxy instance turns into the real instance on first start. Required resources are also loaded only after the first start. * @param {ccm.types.index|ccm.types.url|ccm.types.component} component - URL of ccm component * @param {ccm.types.config} [config={}] - ccm instance configuration, see documentation of associated ccm component * @returns {Promise} */ proxy: async ( component, config ) =&gt; { const obj = { ccm: true, component: { Instance: true } }; obj.start = async cfg =&gt; await Object.assign( obj, await ccm.instance( component, await ccm.helper.integrate( cfg, config ) ) ).start(); return obj; }, /** * @summary registers a component, creates an instance out of it and starts the instance * @description * This method does the same as {@link ccm.instance} with the difference that the created [instance]{@link ccm.types.instance} is started directly. * See {@tutorial usage-of-components} to learn everything about _ccmjs_-based components and their instances. * @param {ccm.types.component_obj|string} component - component object or URL of a component file * @param {Object} [config] - instance configuration (check documentation of associated component to see which properties could be set) * @returns {Promise&lt;ccm.types.instance&gt;} * @example * const instance = await ccm.start( { * name: 'blank', * ccm: 'https://ccmjs.github.io/ccm/ccm.js', * Instance: function () { * this.start = async () =&gt; { * this.element.innerHTML = 'Hello, World!'; * }; * } * }, { root: document.body } ); * @example * const instance = await ccm.start( * 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js', * { root: document.body } * ); * @tutorial usage-of-components */ start: async ( component, config ) =&gt; { const instance = await ccm.instance( component, config ); if ( !ccm.helper.isInstance( instance ) ) return instance; instance.init ? ( instance._start = true ) : await instance.start(); return instance; }, /** * @summary provides access to a datastore * @description * _ccmjs_ provides a service for data management. It could be used with this method. * Use the methods &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;del&lt;/code&gt; of the result object to create, read, update or delete datasets in the datastore. * This method can be used to define dependencies to other datastores in [instance configurations]{@link ccm.types.instance_config}. * @param {Object} [config={}] - datastore accessor configuration * @returns {Promise&lt;ccm.types.datastore&gt;} datastore accessor * @tutorial data-management */ store: ( config = {} ) =&gt; new Promise( ( resolve, reject ) =&gt; { // no manipulation of passed original parameter (avoids unwanted side effects) config = ccm.helper.clone( config ); // is string? =&gt; use passed parameter as datastore name or path to a JavaScript file that contains initial data for local cache if ( typeof config === 'string' ) config = config.split( '?' ).shift().endsWith( '.js' ) ? { local: [ 'ccm.load', config ] } : { name: config }; // is no datastore configuration? =&gt; use passed parameter for initial local cache if ( !ccm.helper.isObject( config ) || ( !config.local &amp;&amp; !config.name ) ) { config = { local: config, parent: config.parent }; delete config.local.parent; } // no initial local cache? =&gt; use empty object if ( !config.local &amp;&amp; !config.name ) config.local = {}; // initial local cache is given as ccm dependency? =&gt; solve dependency ccm.helper.solveDependency( config.local ).then( result =&gt; { config.local = result; // local cache is given as array? =&gt; convert to object if ( Array.isArray( config.local ) ) config.local = ccm.helper.arrToStore( config.local ); /** * created ccm datastore * @type {ccm.Datastore} */ let store = new Datastore(); // integrate datastore configuration Object.assign( store, config ); // initialize ccm datastore and perform callback with created ccm datastore store.init().then( () =&gt; resolve( store ) ); } ).catch( reject ); } ), /** * @summary reads a dataset of a datastore * @description * This method does the same as {@link ccm.store} with the difference that a [dataset]{@link ccm.types.dataset} is directly read from the datastore. * The dataset is returned as result. Use this method if you only read a dataset once and then need no further access to the datastore. * This method can be used to define dependencies to other datasets in [instance configurations]{@link ccm.types.instance_config}. * In order to read only a certain subset of a dataset, the dot notation can be used in the &lt;code&gt;key_or_query&lt;/code&gt; parameter. * Then the complete dataset is read but the result is only the requested subset. * If a query is passed instead of a [dataset key]{@link ccm.types.dataset_key}, several datasets can be loaded. * @param {Object} [config={}] - datastore accessor configuration * @param {ccm.types.key|Object} [key_or_query={}] - either a dataset key or a query to read several datasets (default: read all datasets) * @returns {Promise&lt;ccm.types.dataset|ccm.types.dataset[]&gt;} * @tutorial data-management */ get: ( config = {}, key_or_query = {} ) =&gt; ccm.store( config ).then( store =&gt; { // support dot notation to get a specific inner value of a single dataset let property; if ( typeof key_or_query === 'string' ) { property = key_or_query.split( '.' ); key_or_query = property.shift(); property = property.join( '.' ); } // request dataset in datastore return store.get( key_or_query ).then( result =&gt; property ? ccm.helper.deepValue( result, property ) : result ); } ), /** * @description Returns the _ccmjs_ version. * @returns {ccm.types.version_nr} */ version: () =&gt; '26.0.0', /** * Global namespace under which each registered component can provide public data and functions to the webpage under its unique [component index]{@link ccm.types.component_index}. * This namespace is helpful to see which component version is already registered in which _ccmjs_ version within the webpage. * The namespace is usually not used by component developers. * @type {Object} * @example * { * 'chat-1-0-2': { * valid: true * }, * 'quiz-1-0-0': { * foo: 'bar', * sayHello: name =&gt; console.log( 'Hello ' + name ) * }, * 'quiz-2-1-0': { * n: 5711 * } * }; * @tutorial usage-of-components */ components: {}, /** * @ignore * @summary context functions for traversing in a _ccmjs_ context tree * @namespace * @ignore */ context: { /** * @summary [deprecated] finds nearest parent that has a specific property * @param {ccm.types.instance} instance - starting point * @param {string} property - name of specific property * @param {boolean} not_me - exclude starting point and start with its parent * @returns {ccm.types.instance} property value */ find: ( instance, property, not_me ) =&gt; { const start = instance; if ( not_me ) instance = instance.parent; do if ( ccm.helper.isObject( instance ) &amp;&amp; instance[ property ] !== undefined &amp;&amp; instance[ property ] !== start ) return instance[ property ]; while ( instance = instance.parent ); }, /** * @summary finds the highest parent instance that has a specific property * @param {ccm.types.instance} instance - starting point * @param {string} property - name of specific property * @param {boolean} not_me - exclude starting point and start with its parent * @returns {ccm.types.instance|null} highest parent instance that has a specific property */ highestByProperty: ( instance, property, not_me ) =&gt; { const start = instance; let result = null; if ( not_me ) instance = instance.parent; do if ( ccm.helper.isObject( instance ) &amp;&amp; instance[ property ] !== undefined &amp;&amp; instance[ property ] !== start ) result = instance; while ( instance = instance.parent ); return result; }, /** * @summary finds the nearest parent instance that has a specific property * @param {ccm.types.instance} instance - starting point * @param {string} property - name of specific property * @param {boolean} not_me - exclude starting point and start with its parent * @returns {ccm.types.instance|null} highest parent instance that has a specific property */ nearestByProperty: ( instance, property, not_me ) =&gt; { const start = instance; if ( not_me ) instance = instance.parent; do if ( ccm.helper.isObject( instance ) &amp;&amp; instance[ property ] !== undefined &amp;&amp; instance[ property ] !== start ) return instance; while ( instance = instance.parent ); return null; }, /** * @summary get _ccmjs_ context root * @param {ccm.types.instance} instance - _ccmjs_ instance (starting point) * @returns {ccm.types.instance} */ root: function ( instance ) { while ( instance.parent ) instance = instance.parent; return instance; } }, /** * Contains useful help methods that can be used by component developers. * @namespace */ helper: { /** * @summary converts an array of datasets to a collection of _ccmjs_ datasets * @param {ccm.types.dataset[]} arr - array of datasets * @returns {ccm.types.datasets} collection of _ccmjs_ datasets */ arrToStore: arr =&gt; { if ( !Array.isArray( arr ) ) return; const obj = {}; arr.forEach( value =&gt; { if ( ccm.helper.isDataset( value ) ) obj[ value.key ] = value; } ); return obj; }, /** * @summary create a deep copy of a given value * @param {*} value - given value * @returns {*} deep copy of given value */ clone: function ( value ) { return recursive( value, true ); function recursive( value, first ) { if ( ccm.helper.isSpecialObject( value ) &amp;&amp; !first ) return value; if ( Array.isArray( value ) || ccm.helper.isObject( value ) ) { var copy = Array.isArray( value ) ? [] : {}; for ( var i in value ) copy[ i ] = recursive( value[ i ] ); return copy; } return value; } }, /** * @summary compares two version numbers (given as string) * @description Version numbers must be conform with Semantic Versioning 2.0.0 ({@link http://semver.org}). * @param {string} a - 1st version number * @param {string} b - 2nd version number * @returns {number} -1: a &lt; b, 0: a = b, 1: a &gt; b * @example console.log( compareVersions( '8.0.1', '8.0.10' ) ); =&gt; -1 */ compareVersions: ( a, b ) =&gt; { if ( a === b ) return 0; const a_arr = a.split( '.' ); const b_arr = b.split( '.' ); for ( let i = 0; i &lt; 3; i++ ) { const x = parseInt( a_arr[ i ] ); const y = parseInt( b_arr[ i ] ); if ( x &lt; y ) return -1; else if ( x &gt; y ) return 1; } return 0; }, /** * @summary extract data from the URL of a ccm component * @description * The result data contains the unique 'name', 'version' and 'index' of the component.&lt;br&gt; * The 'minified' flag is set if the filename contains a \".min\". * @param {string} url - ccm component URL * @returns {{name: string, index: string, version: string, url: string, minified: boolean}} extracted data * @throws {Error} if component filename is not valid * @example * const data = ccm.helper.convertComponentURL( './ccm.quiz-4.0.2.js' ); * console.log( data ); // {\"name\":\"quiz\",\"version\":\"4.0.2\",\"index\":\"quiz-4-0-2\",\"url\":\"./ccm.quiz-4.0.2.js\"} * @example * const data = ccm.helper.convertComponentURL( './ccm.quiz.js' ); // latest version * console.log( data ); // {\"name\":\"quiz\",\"index\":\"quiz\",\"url\":\"./ccm.quiz.js\"} * @example * const data = ccm.helper.convertComponentURL( './ccm.quiz.min.js' ); // minified * console.log( data ); // {\"name\":\"quiz\",\"index\":\"quiz\",\"url\":\"./ccm.quiz.min.js\",\"minified\":true} */ convertComponentURL: url =&gt; { /** * from given url extracted filename of the ccm component * @type {string} */ const filename = url.split( '/' ).pop(); // abort if extracted filename is not a valid filename for a ccm component if ( !ccm.helper.regex( 'filename' ).test( filename ) ) throw new Error( 'invalid component filename: ' + filename ); // extract data const data = { url: url }; let tmp = filename.substring( 4, filename.length - 3 ); // remove prefix 'ccm.' and postfix '.js' if ( tmp.endsWith( '.min' ) ) { data.minified = true; tmp = tmp.substr( 0, tmp.length - 4 ); // removes optional infix '.min' } tmp = tmp.split( '-' ); data.name = tmp.shift(); // name if ( tmp.length ) data.version = tmp[ 0 ]; // version data.index = data.name + ( data.version ? '-' + data.version.replace( /\\./g, '-' ) : '' ); // index return data; }, /** * @summary get or set the value of a deeper object property * @param {Object} obj - object that contains the deeper property * @param {string} key - key path to the deeper property in dot notation * @param {*} [value] - value that should be set for the deeper property * @returns {*} value of the deeper property * @example * var obj = { * test: 123, * foo: { * bar: 'abc', * baz: 'xyz' * } * }; * var result = ccm.helper.deepValue( obj, 'foo.bar' ); * console.log( result ); // =&gt; 'abc' * @example * var obj = {}; * var result = ccm.helper.deepValue( obj, 'foo.bar', 'abc' ); * console.log( obj ); // =&gt; { foo: { bar: 'abc' } } * console.log( result ); // =&gt; 'abc' */ deepValue: function ( obj, key, value ) { return recursive( obj, key.split( '.' ), value ); /** * recursive helper function, key path is given as array */ function recursive( obj, key, value ) { if ( !obj ) return; var next = key.shift(); if ( key.length === 0 ) return value !== undefined ? obj[ next ] = value : obj[ next ]; if ( !obj[ next ] &amp;&amp; value !== undefined ) obj[ next ] = isNaN( key[ 0 ] ) ? {} : []; return recursive( obj[ next ], key, value ); // recursive call } }, /** * @summary replaces placeholder in data with given values * @param {*} data - data with contained placeholders * @param {...*} [values] - given values * @returns {*} data with replaced placeholders */ format: function ( data, values ) { const temp = [[],[],{}]; const obj_mode = ccm.helper.isObject( data ); // convert given values to real array values = ccm.helper.clone( [ ...arguments ] ); values.shift(); // convert data to string data = ccm.helper.stringify( data, ( key, val ) =&gt; { // rescue all functions and replace them with special placeholder if ( typeof val === 'function' ) { temp[ 0 ].push( val ); return '%$0%'; } return val; } ); // replace placeholders with values for ( let i = 0; i &lt; values.length; i++ ) { // value is object or array? =&gt; iterate each contained value if ( typeof values[ i ] === 'object' ) { for ( const key in values[ i ] ) if ( values[ i ].hasOwnProperty( key ) ) { // value is not a string and data is object? if ( typeof values[ i ][ key ] !== 'string' &amp;&amp; obj_mode ) { temp[ 2 ][ key ] = values[ i ][ key ]; // rescue value values[ i ][ key ] = `%$2%${key}%`; // replace value with special placeholder } // value is not a string? =&gt; skip replacement if ( typeof values[ i ][ key ] !== 'string' ) continue; // replace all associated placeholders with value data = data.replace( new RegExp( `%${key}%`, 'g' ), values[ i ][ key ].replace( /\"/g, '\\\\\"' ) ); } } // neither object nor array else { // value is not a string and data is object? =&gt; rescue value and replace it with special placeholder if ( typeof values[ i ] !== 'string' &amp;&amp; obj_mode ) { temp[ 1 ].push( values[ i ] ); // rescue value values[ i ] = '%$1%'; // replace value with special placeholder } // replace first occurrence of empty placeholder with value data = data.replace( /%%/, values[ i ].replace( /\"/g, '\\\\\"' ) ); } } // convert data from string back to original return ccm.helper.parse( data, ( key, val ) =&gt; { // replace special placeholders with rescued values if ( val === '%$0%' ) return temp[ 0 ].shift(); if ( val === '%$1%' ) return temp[ 1 ].shift(); if ( typeof val === 'string' ) { // is standalone placeholder =&gt; keep original datatype if ( val.indexOf( '%$2%' ) === 0 &amp;&amp; val.split( '%' )[ 3 ] === '' ) return temp[ 2 ][ val.split( '%' )[ 2 ] ]; // placeholder is part of string? =&gt; replace (datatype is converted to string) else for ( const key in temp[ 2 ] ) val = val.replace( new RegExp( `%\\\\$2%${key}%`, 'g' ), temp[ 2 ][ key ] ); } return val; } ); }, /** * @summary generates an instance configuration out of a HTML element * @param {string|ccm.types.html|ccm.types.html[]|Node|jQuery} element - HTML element * @returns {ccm.types.config} */ generateConfig: element =&gt; { // convert to HTML element element = ccm.helper.html( element, undefined, { no_evaluation: true } ); // innerHTML is a JSON string? =&gt; move it to attribture 'inner' if ( ccm.helper.regex( 'json' ).test( element.innerHTML ) ) { element.setAttribute( 'inner', element.innerHTML ); element.innerHTML = ''; } const config = {}; catchAttributes( element, config ); catchInnerTags( element ); return config; function catchAttributes( element, obj ) { if ( !element.attributes ) return; [ ...element.attributes ].forEach( attr =&gt; { if ( attr.name !== 'src' || ( element.tagName.indexOf( 'CCM-COMPONENT' ) !== 0 &amp;&amp; element.tagName.indexOf( 'CCM-INSTANCE' ) !== 0 &amp;&amp; element.tagName.indexOf( 'CCM-PROXY' ) !== 0 ) ) try { obj[ attr.name ] = attr.value.charAt( 0 ) === '{' || attr.value.charAt( 0 ) === '[' ? ccm.helper.parse( attr.value ) : prepareValue( attr.value ); } catch ( err ) {} } ); } function catchInnerTags( element ) { if ( !element.childNodes ) return; config.childNodes = []; [ ...element.childNodes ].forEach( child =&gt; { if ( child.tagName &amp;&amp; child.tagName.indexOf( 'CCM-' ) === 0 ) { const split = child.tagName.toLowerCase().split( '-' ); if ( split.length &lt; 3 ) split[ 2 ] = split[ 1 ]; switch ( split[ 1 ] ) { case 'load': ccm.helper.deepValue( config, split[ 2 ], interpretLoadTag( child, split[ 2 ] ) ); break; case 'component': case 'instance': case 'proxy': ccm.helper.deepValue( config, split[ 2 ], [ 'ccm.' + split[ 1 ], child.getAttribute( 'src' ) || split[ 2 ], ccm.helper.generateConfig( child ) ] ); break; case 'store': case 'get': const settings = {}; catchAttributes( child, settings ); const key = settings.key; delete settings.key; ccm.helper.deepValue( config, split[ 2 ], [ 'ccm.' + split[ 1 ], settings, key ] ); break; case 'list': let list = null; [ ...child.children ].forEach( entry =&gt; { if ( entry.tagName &amp;&amp; entry.tagName.indexOf( 'CCM-ENTRY' ) === 0 ) { const value = prepareValue( entry.getAttribute( 'value' ) ); const split = entry.tagName.toLowerCase().split( '-' ); if ( !list ) list = split.length &lt; 3 ? [] : {}; if ( split.length &lt; 3 ) list.push( value ); else ccm.helper.deepValue( list, split[ 2 ], value ); } } ); if ( !list ) list = {}; catchAttributes( child, list ); if ( list ) ccm.helper.deepValue( config, split[ 2 ], list ); break; default: config.childNodes.push( child ); element.removeChild( child ); } } else { config.childNodes.push( child ); element.removeChild( child ); } } ); if ( config.inner ) return; config.inner = ccm.helper.html( {} ); config.childNodes.forEach( child =&gt; config.inner.appendChild( child ) ); delete config.childNodes; if ( !config.inner.hasChildNodes() ) delete config.inner; function interpretLoadTag( node ) { let params = generateParameters( node ); if ( !Array.isArray( params ) ) params = [ params ]; params.unshift( 'ccm.load' ); if ( node.hasAttribute( 'head' ) ) params.push( true ); return params; function generateParameters( node ) { if ( node.hasAttribute( 'src' ) ) { if ( node.children.length === 0 ) return node.getAttribute( 'src' ); const data = {}; [ ...node.children ].forEach( child =&gt; { if ( child.tagName &amp;&amp; child.tagName.indexOf( 'CCM-DATA-' ) === 0 ) data[ child.tagName.toLowerCase().split( '-' )[ 2 ] ] = child.getAttribute( 'value' ); } ); return [ node.getAttribute( 'src' ), data ]; } const params = []; [ ...node.children ].forEach( child =&gt; { if ( child.tagName === 'CCM-SERIAL' &amp;&amp; ( node.tagName === 'CCM-PARALLEL' || node.tagName.indexOf( 'CCM-LOAD' ) === 0 ) || child.tagName === 'CCM-PARALLEL' &amp;&amp; node.tagName === 'CCM-SERIAL' ) params.push( generateParameters( child ) ); } ); return params; } } } function prepareValue( value ) { if ( value === 'true' ) return true; if ( value === 'false' ) return false; if ( value === 'null' ) return null; if ( value === 'undefined' ) return undefined; if ( value === '' ) return true; if ( !isNaN( value ) ) return parseInt( value ); return value; } }, /** * @summary generates a unique key * @description * An automatic generated unique key is made up of three parts. * The first part is the current time in milliseconds. * The second part is an 'X' as separator between first and last part. * The last part is a random number. * @returns {ccm.types.key} unique key * @example console.log( ccm.helper.generateKey() ); // 1465718738384X6869462723575014 */ generateKey: function () { return Date.now() + 'X' + Math.random().toString().substr( 2 ); }, /** * transforms HTML to a HTML element and replaces placeholders (recursive) * @param {string|ccm.types.html|ccm.types.html[]|Node|jQuery|function} html * @param {...string|Object} [values] - values to replace placeholder * @param {Object} [settings] - advanced settings * @param {boolean} [settings.no_evaluation] - skips evaluation of ccm HTML elements * @param {string} [settings.namespace_uri] - sets namespace URI for created elements * @returns {Element|Element[]} HTML element */ html: function ( html, ...values ) { // no HTML? =&gt; abort if ( !html ) return html; // is already a HTML element and no placeholders have to be replaced? =&gt; nothing to do if ( ccm.helper.isElement( html ) &amp;&amp; values === undefined ) return html; // is function that returns a lit-html template result? if ( typeof html === 'function' ) return html.apply( this, values ); // handle advanced settings let advanced = {}; if ( ccm.helper.isObject( values[ values.length - 1 ] ) ) advanced = values.pop(); // convert HTML to ccm HTML data html = ccm.helper.html2json( html ); // clone HTML data html = ccm.helper.clone( html ); // replace placeholder if ( values.length ) { values.unshift( html ); html = ccm.helper.format.apply( this, values ); } // get more than one HTML tag? if ( Array.isArray( html ) ) { // generate each HTML tag const result = []; for ( let i = 0; i &lt; html.length; i++ ) result.push( ccm.helper.html( html[ i ], advanced ) ); // recursive call return result; } // get no ccm html data? =&gt; return parameter value if ( typeof html !== 'object' || html === null ) html = { tag: 'span', inner: html }; // is SVG? =&gt; create elements with the SVG namespace URI if ( html.tag === 'svg' ) advanced.namespace_uri = 'http://www.w3.org/2000/svg'; /** * HTML tag * @type {Element} */ const element = advanced.namespace_uri ? document.createElementNS( advanced.namespace_uri, html.tag || 'div' ) : document.createElement( html.tag || 'div' ); // remove 'tag' and 'key' property delete html.tag; if ( !ccm.helper.regex( 'json' ).test( html.key ) ) delete html.key; // iterate over ccm html data properties for ( const key in html ) { /** * value of ccm html data property * @type {string|ccm.types.html|Array} */ const value = html[ key ]; // interpret ccm html data property switch ( key ) { // HTML boolean attributes case 'async': case 'autofocus': case 'checked': case 'defer': case 'disabled': case 'ismap': case 'multiple': case 'required': case 'selected': if ( value ) element[ key ] = true; break; case 'readonly': if ( value ) element.readOnly = true; break; // inner HTML case 'inner': if ( typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' ) { element.innerHTML = value; break; } let children = Array.isArray( value ) ? value : [ value ]; children.forEach( child =&gt; element.appendChild( this.html( child, undefined, advanced ) ) ); break; // HTML value attributes and events default: if ( key.indexOf( 'on' ) === 0 &amp;&amp; typeof value === 'function' ) // is HTML event element.addEventListener( key.substr( 2 ), value ); else // is HTML value attribute element.setAttribute( key, value ); } } // is ccm HTML Element of registered component and evaluation is not skipped? =&gt; evaluate ccm HTML Element if ( element.tagName.startsWith( 'CCM-' ) &amp;&amp; !advanced.no_evaluation ) { const config = ccm.helper.generateConfig( element ); config.root = element; ccm.start( element.tagName === 'CCM-APP' ? element.getAttribute( 'component' ) : element.tagName.substr( 4 ).toLowerCase(), config ); } // return generated HTML return element; }, /** * converts HTML to JSON * @param {string|jQuery|DocumentFragment|Element|ccm.types.html} html * @returns {ccm.types.html} ccm HTML data */ html2json: html =&gt; { /** * ccm HTML data * @type {Object} */ const json = { inner: [] }; // is HTML string? =&gt; convert to document fragment if ( typeof html === 'string' ) { const template = document.createElement( 'template' ); template.innerHTML = html; html = template.content; } // is jQuery element? =&gt; convert to document fragment if ( window.jQuery &amp;&amp; html instanceof jQuery ) { html = html.get(); const fragment = document.createDocumentFragment(); html.forEach( elem =&gt; fragment.appendChild( elem ) ); html = fragment; } // is document fragment? if ( html instanceof DocumentFragment ) { // content is only text? =&gt; return text as result if ( !html.children.length ) return html.textContent; // remove whitespaces, comments and empty text nodes [ ...html.childNodes ].forEach( child =&gt; { if ( child.nodeValue ) { child.nodeValue = child.nodeValue.trim(); if ( !child.nodeValue || child.nodeType === Node.COMMENT_NODE ) child.parentNode.removeChild( child ); } } ); // only one child? =&gt; use child as root element if ( html.childNodes.length === 1 ) html = html.firstChild; } // no HTML Element? =&gt; return it as result if ( !ccm.helper.isElement( html ) ) return html; // catch tag name if ( html.tagName ) json.tag = html.tagName.toLowerCase(); if ( json.tag === 'div' ) delete json.tag; // catch HTML attributes html.attributes &amp;&amp; [ ...html.attributes ].forEach( attr =&gt; json[ attr.name ] = attr.value === '' &amp;&amp; attr.name !== 'value' ? true : attr.value ); // catch inner HTML (recursive) [ ...html.childNodes ].forEach( child =&gt; { if ( child.nodeType === Node.COMMENT_NODE ) return child.parentNode.removeChild( child ); if ( child.nodeValue ) child.nodeValue = child.nodeValue.replace( /\\s+/g, ' ' ); if ( ccm.helper.isElement( child ) || child.nodeValue.trim() ) json.inner.push( ccm.helper.isElement( child ) ? ccm.helper.html2json( child ) : child.textContent ); } ); if ( !json.inner.length ) delete json.inner; else if ( json.inner.length === 1 ) json.inner = json.inner[ 0 ]; return json; }, /** * @summary integrates priority data into a given dataset * @description * Each value of each property in the given priority data will be set in the given dataset for the property of the same name. * This method also supports dot notation in given priority data to set a single deeper property in the given dataset. * With no given priority data, the result is the given dataset. * With no given dataset, the result is the given priority data. * Any data dependencies are resolved before integration. * @param {Object} [priodata] - priority data * @param {Object} [dataset] - dataset * @param {boolean} [as_defaults] - integrate values only if not already exist * @returns {Object} dataset with integrated priority data * @example * const dataset = { firstname: 'John', lastname: 'Doe', fullname: 'John Doe' }; * const priodata = { lastname: 'Done', fullname: undefined }; * const result = await ccm.helper.integrate( priodata, dataset ); * console.log( result ); // { firstname: 'John', lastname: 'Done', fullname: undefined }; * @example * const result = await ccm.helper.integrate( { 'foo.c': 'z' }, { foo: { a: 'x', b: 'y' } } ); * console.log( result ); // { foo: { a: 'x', b: 'y', c: 'z' } } * @example * const result = await ccm.helper.integrate( { value: 'foo' } ); * console.log( result ); // { value: 'foo' } * @example * const result = await ccm.helper.integrate( undefined, { value: 'foo' } ); * console.log( result ); // { value: 'foo' } * @example * const store = { data: { key: 'data', foo: 'bar' } }; * const result = await ccm.helper.integrate( { 'value.foo': 'baz' }, { value: [ 'ccm.get', { local: store }, 'data' ] } ); * console.log( result ); // { value: { foo: 'baz' } } */ integrate: async ( priodata, dataset, as_defaults ) =&gt; { dataset = ccm.helper.clone( dataset ); // no given priority data? =&gt; return given dataset if ( !ccm.helper.isObject( priodata ) ) return dataset; // no given dataset? =&gt; return given priority data if ( !ccm.helper.isObject( dataset ) ) return ccm.helper.clone( priodata ); // iterate over priority data properties for ( let key in priodata ) { // search and solve data dependencies along key path before integration of priority data value const split = key.split( '.' ); let obj = dataset; for ( let i = 0; i &lt; split.length; i++ ) { const prop = split[ i ]; if ( ccm.helper.isDependency( obj[ prop ] ) &amp;&amp; obj[ prop ][ 0 ] === 'ccm.get' ) obj[ prop ] = await ccm.helper.solveDependency( obj[ prop ] ); obj = obj[ prop ]; if ( !obj ) break; } // set value for the same property in the given dataset const value = ccm.helper.deepValue( dataset, key ); if ( !as_defaults || value === undefined || value === '' ) ccm.helper.deepValue( dataset, key, priodata[ key ] ); } // return dataset with integrated priority data return dataset; }, /** * @summary check value for _ccmjs_ component * @param {*} value - value to check * @returns {boolean} */ isComponent: function ( value ) { return ccm.helper.isObject( value ) &amp;&amp; value.Instance &amp;&amp; true; }, /** * checks if a value is a ccm dataset * @param {*} value - value to check * @returns {boolean} */ isDataset: value =&gt; ccm.helper.isObject( value ) &amp;&amp; ccm.helper.isKey( value.key ), /** * checks if a value is a ccm datastore object * @param {*} value - value to check * @returns {boolean} */ isDatastore: value =&gt; ccm.helper.isObject( value ) &amp;&amp; value.get &amp;&amp; value.set &amp;&amp; value.del &amp;&amp; value.source &amp;&amp; value.clear &amp;&amp; true, /** * check value if it is a _ccmjs_ dependency * @param {*} value * @returns {boolean} * @example [ ccm.load, ... ] * @example [ ccm.component, ... ] * @example [ ccm.instance, ... ] * @example [ ccm.proxy, ... ] * @example [ ccm.start, ... ] * @example [ ccm.store, ... ] * @example [ ccm.get, ... ] * @example [ ccm.set, ... ] * @example [ ccm.del, ... ] */ isDependency: function ( value ) { if ( Array.isArray( value ) ) if ( value.length &gt; 0 ) switch ( value[ 0 ] ) { case 'ccm.load': case 'ccm.component': case 'ccm.instance': case 'ccm.proxy': case 'ccm.start': case 'ccm.store': case 'ccm.get': case 'ccm.set': case 'ccm.del': return true; } return false; }, /** * @summary check value for HTML element node * @param {*} value - value to check * @returns {boolean} */ isElement: function ( value ) { return value instanceof Element || value instanceof DocumentFragment; //return self.helper.isNode( value ) &amp;&amp; value.tagName &amp;&amp; true; }, /** * @summary checks if a value is a _ccmjs_ ccmjs object * @param {*} value - value to check * @returns {boolean} */ isCore: value =&gt; ccm.helper.isObject( value ) &amp;&amp; value.components &amp;&amp; value.version &amp;&amp; true, /** * @summary checks if a value is a _ccmjs_ instance * @param {*} value - value to check * @returns {boolean} */ isInstance: value =&gt; ccm.helper.isObject( value ) &amp;&amp; ccm.helper.isComponent( value.component ) &amp;&amp; value.ccm &amp;&amp; true, /** * checks if a value is a valid ccm dataset key * @param {*} value - value to check * @returns {boolean} */ isKey: value =&gt; { // value is a string? =&gt; check if it is an valid key if ( typeof value === 'string' ) return ccm.helper.regex( 'key' ).test( value ); // value is an array? =&gt; check if it is an valid array key if ( Array.isArray( value ) ) { for ( let i = 0; i &lt; value.length; i++ ) if ( !ccm.helper.regex( 'key' ).test( value[ i ] ) ) return false; return true; } // value is not a dataset key? =&gt; not valid return false; }, /** * @summary check value for HTML node * @param {*} value - value to check * @returns {boolean} */ isNode: function ( value ) { return value instanceof Node; }, /** * check value if it is an object (including not null and not array) * @param {*} value - value to check * @returns {boolean} */ isObject: function ( value ) { return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray( value ); }, /** * @summary checks if a value is an ccm proxy instance * @param {*} value - value to check * @returns {boolean} */ isProxy: function ( value ) { return ccm.helper.isInstance( value ) &amp;&amp; value.component === true; }, /** * @summary checks if a value is a special object: (Window Object, Node, ccmjs Object, ccm Instance, ccm Component Object, ccm Datastore, jQuery Object) * @param {*} value * @returns {boolean} */ isSpecialObject: value =&gt; { return !!( value === window || ccm.helper.isNode( value ) || ccm.helper.isCore( value ) || ccm.helper.isInstance( value ) || ccm.helper.isComponent( value ) || ccm.helper.isDatastore( value ) || window.jQuery &amp;&amp; value instanceof jQuery ); }, /** * checks if an object is a subset of another object * @param {Object} obj - object * @param {Object} other - another object * @returns {boolean} * @example * const obj = { * name: 'John Doe', * counter: 3, * isValid: true, * x: { y: 'z' }, // check of inner object * 'values.1': 123, // check of deeper array value * 'settings.title': 'Welcome!' // check of deeper object value * }; * const other = { * name: 'John Doe', * counter: 3, * isValid: true, * values: [ 'abc', 123, false ], * settings: { title: 'Welcome!', year: 2017, greedy: true }, * x: { y: 'z' }, * onLoad: function () { console.log( 'Loading..' ); } * }; * const result = ccm.helper.isSubset( obj, other ); * console.log( result ); // =&gt; true */ isSubset: function ( obj, other ) { other = ccm.helper.toDotNotation( other, true ); for ( const key in obj ) if ( typeof obj[ key ] === 'object' &amp;&amp; typeof other[ key ] === 'object' ) { if ( JSON.stringify( obj[ key ] ) !== JSON.stringify( other[ key ] ) ) return false; } else if ( obj[ key ] !== other[ key ] ) return false; return true; }, /** * loads a ccmjs version * @param {string|{url: string, integrity: string, crossorigin: string}} url - ccmjs version URL * @returns {Promise&lt;Object&gt;} namespace of loaded ccmjs version */ loadVersion: async url =&gt; { // prepare resource data let resource = {}; if ( ccm.helper.isObject( url ) ) { url = ccm.helper.clone( url ); resource.url = url.url; delete url.url; resource.attr = url; } else resource = { url: url }; /** * ccmjs version number * @type {string} */ const version = ( resource.url.match( /(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)/ ) || [ '' ] )[ 0 ]; // load needed ccmjs version if not already there version &amp;&amp; !window.ccm[ version ] &amp;&amp; await ccm.load( resource ); return version ? window.ccm[ version ] : window.ccm; }, /** * returns a _ccmjs_ loading icon * @param {Object} [instance] - _ccmjs_ instance (for determining Shadow DOM) * @returns {Element} _ccmjs_ loading icon * @example document.body.appendChild( loading() ) * @example document.body.appendChild( loading( instance ) ) */ loading: instance =&gt; { // set keyframe for ccm loading icon animation let element = instance ? instance.element.parentNode : document.head; if ( !element.querySelector( '#ccm_keyframe' ) ) { const style = document.createElement( 'style' ); style.id = 'ccm_keyframe'; style.appendChild( document.createTextNode( '@keyframes ccm_loading { to { transform: rotate( 360deg ); } }' ) ); element.appendChild( style ); } // create loading icon element = document.createElement( 'div' ); element.classList.add( 'ccm_loading' ); element.setAttribute( 'style', 'display: grid; padding: 0.5em;' ); element.innerHTML = '&lt;div style=\"align-self: center; justify-self: center; display: inline-block; width: 2em; height: 2em; border: 0.3em solid #f3f3f3; border-top-color: #009ee0; border-left-color: #009ee0; border-radius: 50%; animation: ccm_loading 1.5s linear infinite;\"&gt;&lt;/div&gt;'; return element; }, /** * logs a ccm-specific message in the browser console * @param {*} message */ log: message =&gt; console.log( '[ccmjs]', message ), /** * converts a JSON string to JSON and removes hidden characters * @param {string} string - JSON string * @param {Function} [reviver] * @returns {*} JSON */ parse: ( string, reviver ) =&gt; JSON.parse( string .replace( /\\\\n/g, \"\\\\n\" ) .replace( /\\\\'/g, \"\\\\'\" ) .replace( /\\\\\"/g, '\\\\\"' ) .replace( /\\\\&amp;/g, \"\\\\&amp;\" ) .replace( /\\\\r/g, \"\\\\r\" ) .replace( /\\\\t/g, \"\\\\t\" ) .replace( /\\\\b/g, \"\\\\b\" ) .replace( /\\\\f/g, \"\\\\f\" ) .replace( /[\\u0000-\\u0019]+/g, \"\" ), reviver ), /** * @summary get a _ccmjs_ relevant regular expression * @description * Possible index values, it's meanings and it's associated regular expressions: * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;index&lt;/th&gt; * &lt;th&gt;meaning&lt;/th&gt; * &lt;th&gt;regular expression&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;'filename'&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;filename for an _ccmjs_ instance&lt;/td&gt; * &lt;td&gt;/^(ccm.)?([^.-]+)(-(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*))?(\\.min)?(\\.js)$/&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;'key'&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;key for a _ccmjs_ dataset&lt;/td&gt; * &lt;td&gt;/^[a-z_0-9][a-zA-Z_0-9]*$/&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * @param {string} index - index of the regular expression * @returns {RegExp} RegExp Object * @example * // test if a given string is a valid filename for an ccm component * var string = 'ccm.dummy-3.2.1.min.js'; * var result = ccm.helper.regex( 'filename' ).test( string ); * console.log( result ); // =&gt; true * @example * // test if a given string is a valid key for a ccm dataset * var string = 'dummy12_Foo3'; * var result = ccm.helper.regex( 'key' ).test( string ); * console.log( result ); // =&gt; true */ regex: function ( index ) { switch ( index ) { case 'filename': return /^ccm\\.([a-z][a-z_0-9]*)(-(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*))?(\\.min)?(\\.js)$/; case 'key': return /^[a-zA-Z0-9_-]+$/; case 'json': return /^(({(.|\\n)*})|(\\[(.|\\n)*])|true|false|null)$/; } }, /** * @summary sets observed responsive breakpoints for an element * @param {Element} element * @param {Object} [breakpoints = { SM: 384, MD: 576, LG: 768, XL: 960 }] * @param {Object} [instance] - ccm instance with an 'onbreakpoint' callback */ responsive: ( element, breakpoints = { SM: 384, MD: 576, LG: 768, XL: 960 }, instance ) =&gt; { let init = true; if ( window.ResizeObserver ) new ResizeObserver( updateBreakpoints ).observe( element ); else { const observer = new MutationObserver( mutations =&gt; mutations.forEach( mutation =&gt; mutation.type === 'attributes' &amp;&amp; mutation.attributeName === 'style' &amp;&amp; updateBreakpoints() ) ); observer.observe( element, { attributes: true } ); document.body.querySelectorAll( '*' ).forEach( element =&gt; observer.observe( element, { attributes: true } ) ); window.addEventListener( 'resize', updateBreakpoints, false ); updateBreakpoints(); } function updateBreakpoints() { const before = element.getAttribute( 'class' ); for ( const key in breakpoints ) element.classList[ element.offsetWidth &gt;= breakpoints[ key ] ? 'add' : 'remove' ]( key ); const after = element.getAttribute( 'class' ); !init &amp;&amp; before !== after &amp;&amp; instance.onbreakpoint &amp;&amp; instance.onbreakpoint( breakpoints[ after.split( ' ' ).pop() ] || 0 ); init = false; } }, /** * @summary solves ccm dependencies contained in an object or array * @param {Object|Array} obj - object or array * @param {ccm.types.instance} [instance] - associated ccm instance * @returns {Promise} */ solveDependencies: ( obj, instance ) =&gt; new Promise( ( resolve, reject ) =&gt; { obj = ccm.helper.clone( obj ); if ( !ccm.helper.isObject( obj ) &amp;&amp; !Array.isArray( obj ) ) return resolve( obj ); let failed = false; let counter = 1; search( obj ); check(); function search( obj ) { if ( ccm.helper.isSpecialObject( obj ) ) return; for ( const key in obj ) if ( obj.hasOwnProperty( key ) ) if ( key !== 'ignore' ) { const value = obj[ key ]; if ( ccm.helper.isDependency( value ) ) { counter++; ccm.helper.solveDependency( obj[ key ], instance ) .then ( result =&gt; { obj[ key ] = result; check(); } ) .catch( result =&gt; { failed = true; obj[ key ] = result; check(); } ); } else if ( ccm.helper.isObject( value ) || Array.isArray( value ) ) search( value ); } } function check() { !--counter &amp;&amp; ( failed ? reject : resolve )( obj ); } } ), /** * @summary solves a ccm dependency * @param {Array} dependency - ccm dependency * @param {ccm.types.instance} [instance] - associated ccm instance * @returns {Promise} */ solveDependency: async ( dependency, instance ) =&gt; { // given value is no ccm dependency? =&gt; result is given value if ( !ccm.helper.isDependency( dependency ) ) return dependency; // prevent changes via original reference dependency = ccm.helper.clone( dependency ); /** * ccm operation to be performed * @type {string} */ const operation = dependency.shift().substr( 'ccm.'.length ); // solve dependency switch ( operation ) { case 'load': instance &amp;&amp; setContext( dependency ); return await ccm.load.apply( null, dependency ); case 'component': case 'instance': case 'proxy': case 'start': case 'set': case 'del': dependency[ 1 ] = await ccm.helper.solveDependency( dependency[ 1 ], instance ); if ( !dependency[ operation === 'store' ? 0 : 1 ] ) dependency[ operation === 'store' ? 0 : 1 ] = {}; if ( instance ) dependency[ operation === 'store' ? 0 : 1 ].parent = instance; return await ccm[ operation ].apply( null, dependency ); case 'store': case 'get': if ( !dependency[ 0 ] ) dependency[ 0 ] = {}; if ( instance ) dependency[ 0 ].parent = instance; return await ccm[ operation ].apply( null, dependency ); } /** * load resources in Shadow DOM of given ccm instance * @param {Array} resources */ function setContext( resources ) { for ( let i = 0; i &lt; resources.length; i++ ) { if ( Array.isArray( resources[ i ] ) ) { setContext( resources[ i ] ); continue; } if ( !ccm.helper.isObject( resources[ i ] ) ) resources[ i ] = { url: resources[ i ] }; if ( !resources[ i ].context ) resources[ i ].context = instance.element.parentNode; } } }, /** * transforms a flat object which has dot notation in it's keys as path to deeper properties to an object with deeper structure (not yet uses in ccmjs) * @param {Object} obj * @returns {Object} */ solveDotNotation: function ( obj ) { obj = ccm.helper.clone( obj ); for ( const key in obj ) if ( key.indexOf( '.' ) !== -1 ) { ccm.helper.deepValue( obj, key, obj[ key ] ); delete obj[ key ]; } return obj; }, /** * converts a value to a JSON string and removes not JSON valid data * @param {*} value * @param {Function} [replacer] * @param {string|number} [space] * @returns {string} JSON string */ stringify: ( value, replacer, space ) =&gt; JSON.stringify( value, ( key, value ) =&gt; { if ( typeof value === 'function' || ccm.helper.isSpecialObject( value ) ) value = null; return replacer ? replacer( key, value ) : value; }, space ), /** * transforms an object with deeper structure to a flat object with dot notation in each key as path to deeper properties * @param {Object} obj - object * @param {boolean} [all_levels] - result contains all levels of dot notation * @returns {Object} */ toDotNotation: function ( obj, all_levels ) { const result = {}; recursive( obj, '' ); return result; function recursive( obj, prefix ) { for ( const key in obj ) { if ( typeof obj[ key ] === 'object' &amp;&amp; !ccm.helper.isSpecialObject( obj[ key ] ) ) { if ( all_levels ) result[ prefix + key ] = obj[ key ]; recursive( obj[ key ], prefix + key + '.' ); } else result[ prefix + key ] = obj[ key ]; } } }, /** * converts a value to valid JSON (removes not JSON valid data like functions, special objects and hidden characters) * @param {*} value * @returns {*} valid JSON */ toJSON: value =&gt; ccm.helper.parse( ccm.helper.stringify( value ) ) }, /** * Timeout limit (in ms) for a resource loaded via {@link ccm.load} (default: no timeout). * @type {number} * @tutorial loading-of-resources */ timeout: 0 }; // set ccmjs version specific namespace if ( ccm.version &amp;&amp; !window.ccm[ ccm.version() ] ) window.ccm[ ccm.version() ] = ccm; // update namespace for latest ccmjs version if ( !window.ccm.version || ccm.helper.compareVersions( ccm.version(), window.ccm.version() ) &gt; 0 ) Object.assign( window.ccm, ccm.helper.clone( ccm ) ); // define Custom Element &lt;ccm-app&gt; defineCustomElement( 'app' ); /** * defines a ccm-specific Custom Element * @param {string} name - element name (without 'ccm-' prefix) * @returns {Promise&lt;void&gt;} */ async function defineCustomElement( name ) { // load polyfill for Custom Elements if ( !( 'customElements' in window ) ) await ccm.load( { url: 'https://ccmjs.github.io/ccm/polyfills/webcomponents-lite.js', attr: { integrity: 'sha384-yEuTKRGFLhOAfHNxaZiiI23KhMelYudrPUNSUK6T5u1+deGEEKsQ89cS0sPIHjyj', crossorigin: 'anonymous' } } ); if ( customElements.get( 'ccm-' + name ) ) return; window.customElements.define( 'ccm-' + name, class extends HTMLElement { async connectedCallback() { if ( !document.body.contains( this ) ) return; let node = this; while ( node = node.parentNode ) if ( node.tagName &amp;&amp; node.tagName.indexOf( 'CCM-' ) === 0 ) return; const config = ccm.helper.generateConfig( this ); this.removeAttribute( 'key' ); config.root = this; await ccm.start( this.tagName === 'CCM-APP' ? this.getAttribute( 'component' ) : name, config ); } } ); } /** * prepares a ccm instance configuration * @param {Object} [config={}] - instance configuration * @param {Object} [defaults={}] - default instance configuration from component object * @returns {Promise} */ async function prepareConfig( config={}, defaults={} ) { // config is given as ccm dependency? =&gt; solve it config = await ccm.helper.solveDependency( config ); // starting point is default instance configuration from component object let result = defaults; // integrate base configuration (config key property) result = await ccm.helper.integrate( await ccm.helper.solveDependency( config.key ), result ); // integrate instance configuration result = await ccm.helper.integrate( config, result ); // delete reserved properties delete result.key; delete result.component; return result; } /** * changes the component used ccmjs version via config * @returns {Promise&lt;void&gt;} */ async function changeVersion( component, config ) { // should use other ccmjs version? =&gt; change used ccmjs version in component object const source = ( config &amp;&amp; config.ccm ) || ( component.config &amp;&amp; component.config.ccm ); if ( source ) { component.ccm = window.ccm[ ( await ccm.helper.loadVersion( source ) ).version() ]; component.ccm.url = ccm.helper.isObject( source ) ? source.url : source; // (considers backward compatibility) config &amp;&amp; delete config.ccm; component.config &amp;&amp; delete component.config.ccm } } /* * @typedef {Function|string|Array} ccm.types.action * @summary _ccmjs_ action data * @example function() { ... } * @example functionName * @example 'functionName' * @example 'my.namespace.functionName' * @example ['my.namespace.functionName','param1','param2'] */ /* * @typedef {ccm.types.action} ccm.types.dependency * @summary _ccmjs_ dependency * @example [ ccm.component, 'ccm.chat.js' ] * @example [ ccm.instance, 'ccm.chat.js' ] * @example [ ccm.start, 'ccm.chat.js' ] * @example [ ccm.load, 'style.css' ] * @example [ ccm.store, { local: 'datastore.json' } ] * @example [ ccm.get, { local: 'datastore.json' }, 'test' ] * @example [ ccm.set, { local: 'datastore.json' }, { key: 'test', foo: 'bar' } ] * @example [ ccm.del, { local: 'datastore.json' }, 'test' ] */ /* * @typedef {Object} ccm.types.html * @summary _ccmjs_ html data - TODO: explain properties of _ccmjs_ html data * @ignore */ /* * @typedef {Object} ccm.types.settings * @summary _ccmjs_ datastore settings * @description * Settings for a _ccmjs_ datastore. * For more informations about providing a _ccmjs_ datastore see the [documentation of the method 'ccm.store']{@link ccm.store}. * The data level in which the stored datasets will managed is dependent on the existing properties in the datastore settings. * No property 'store' results in a _ccmjs_ datastore of data level 1. * An existing property 'store' results in a _ccmjs_ datastore of data level 2. * An existing property 'store' and 'url' results in a _ccmjs_ datastore of data level 3. * @property {ccm.types.datasets|ccm.types.url} local - Collection of initial _ccmjs_ datasets or URL to a json file that deliver initial datasets for local cache. * See [this wiki page]{@link https://github.com/akless/ccm-developer/wiki/Data-Management#data-caching} for more informations about this kind of data caching. * @property {string} store - Name of the datastore in the database. * Dependent on the specific database the datastore has different designations. * For example in IndexedDB this is the name of the Object Store, in MongoDB the name of the Document Store and in MySQL the name of the Table. * This property is not relevant for the first data level. It is only relevant for higher data levels. * @property {string} url - URL to an _ccmjs_ compatible server interface. * This property is only relevant for the third data level. * See [this wiki page]{@link https://github.com/akless/ccm-developer/wiki/Data-Management#server-interface} for more informations about an _ccmjs_ compatible server interface. * @property {string} db - database (in case of a server that offers more than one database) * @property {Function} onchange - Callback when server informs about changed stored datasets. * This property is only relevant for the third data level with real-time communication. * See [this wiki page]{@link https://github.com/akless/ccm-developer/wiki/Data-Management#real-time-communication} for more informations. * @property {ccm.types.instance} user - _ccmjs_ instance for user authentication (not documented yet) | TODO: Wiki page for datastore security * @example * // provides a empty ccm datastore of data level 1 * {} * @example * // provides a ccm datastore of data level 1 with initial datasets from a JSON file * { * local: 'templates.json' * } * @example * // same example but cross domain * { * local: 'http://akless.github.io/ccm-developer/resources/chat/templates.json' * } * // cross domain only works if json file looks like this: ccm.callback[ 'templates.json' ]( {...} ); * @example * // provides a ccm datastore of data level 1 with directly given initial datasets * { * local: { * \"demo\": { * \"key\": \"demo\", * \"text\": \"Hello, World!\", * \"value\": \"4711\" * }, * \"test\": { * \"key\": \"test\", * \"text\": \"My test dataset.\", * \"value\": \"abc\" * } * } * } * @example * // provides a ccm datastore of data level 2 * { * store: 'chat' * } * @example * // provides a ccm datastore of data level 3 using HTTP * { * store: 'chat', // The file interface.php must be * url: 'http://path/to/server/interface.php' // an ccm compatible server interface * } * @example * // provides a ccm realtime datastore of data level 3 using WebSocket * { * store: 'chat', // The file interface.php must be * url: 'ws://path/to/server/interface.php', // an ccm compatible server interface * onchange: function () { * console.log( arguments ); // Shows the server informations about changed * } // stored datasets in the developer console. * } */ /* * @callback ccm.types.storeResult * @summary callback when a provided datastore is ready for use * @param {ccm.Datastore} store - _ccmjs_ datastore * @example function ( store ) { console.log( store ) } */ } )(); /** * @namespace ccm.types * @description _ccmjs_-specific type definitions */ /** * @typedef {string} ccm.types.component_index * @description Each _ccmjs_ component has an unique component index that is made up of a [component name]{@link ccm.types.component_name} and a [version index]{@link ccm.types.version_index} separated with a &lt;code&gt;-&lt;/code&gt;. * @example 'blank-1-0-0' * @example 'chat-2-1-3' * @example 'blank' // no version number means latest version * @example 'chat' */ /** * @typedef {string} ccm.types.component_name * @description Each _ccm_ component has an unique component name. The name must be conform with the regular expression &lt;code&gt;/^[a-z][a-z_0-9]*$/&lt;/code&gt;. * @example 'blank' * @example 'chat' * @example 'my_blank' * @example 'chat2' * @example 'bank_001' */ /** * @typedef {Object} ccm.types.component_obj * @description * A component is represented as a JavaScript object within _ccmjs_. Below you see the typically properties. * &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt;, &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;Instance&lt;/code&gt; and &lt;code&gt;ready&lt;/code&gt; are set by the component developer. * &lt;code&gt;ccm&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;instances&lt;/code&gt; are set by _ccmjs_ during registration. * The component developer may set additional individual properties. * @property {ccm} ccm - _ccmjs_ object used by the component * @property {ccm.types.component_name} name - component name * @property {ccm.types.version_nr} [version] - component version * @property {ccm.types.component_index} index - component index * @property {Object} [config] - default configuration for created instances * @property {Function} [ready] - callback when this component is registered (deleted after one-time call) * @property {Function} instance - creates an instance out of this component * @property {Function} start - creates and starts an instance * @property {Function} Instance - construction plan for instances that can be created out of the component * @property {number} instances - number of created instances (is only used internally to generate instance IDs) * @example { * ccm: {...}, * name: 'chat', * version: [ 2, 1, 3 ], * index: 'chat-2-1-3', * config: {...}, * ready: async () =&gt; {...}, * instance: config =&gt; {...}, * start: config =&gt; {...}, * Instance: function () {...}, * instances: 0 * } */ /** * @typedef {Object} ccm.types.dataset * @description * JSON representation of a dataset that is managed via the _ccmjs_ service for data management. * Every dataset has a property &lt;code&gt;key&lt;/code&gt; which contains the unique [dataset key]{@link ccm.types.dataset_key} of the dataset. * The &lt;code&gt;_&lt;/code&gt; property is reserved for _permission settings_. * @example { * \"key\": \"demo\", * \"text\": \"Hello, World!\", * \"value\": 12, * \"_\": { * \"creator\": \"akless\", * \"realm\": \"guest\", * \"access\": \"creator\" * } * } */ /** * @typedef {(ccm.types.key|ccm.types.key[])} ccm.types.dataset_key * @description * Each [dataset]{@link ccm.types.dataset} that is managed via the _ccmjs_ service for data management has an unique [key]{@link ccm.types.key}. * Array keys are also supported. An array will be internal converted to a string with &lt;code&gt;.join(',')&lt;/code&gt;. * @example \"test\" * @example \"_foo\" * @example \"123\" * @example \"1-ABC-__123\" * @example \"_\" * @example [ \"test\", \"_foo\", \"123\" ] // =&gt; \"test,_foo,123\" * @example [ \"1-ABC-__123\", \"_\" ] // =&gt; \"1-ABC-__123,_\" */ /** * @typedef {Object} ccm.types.html_data * @description * In ccmjs, loaded HTML is automatically converted into a JSON structure. This is than called HTML data. * ... */ /** * @typedef {Object} ccm.types.instance * @description * An object created out of a _ccmjs_ component. Below you see the typically properties. * The component developer may set additional individual properties. * @property {ccm} ccm - _ccmjs_ object used by the instance * @property {ccm.types.component_obj} component - component object from which the instance was created * @property {ccm.types.instance} [parent] - parent instance that has a dependency on this instance * @property {Object.&lt;string,ccm.types.instance&gt;} children - children instances which depend on this instance * @property {string} config - stringified configuration with which the component was created * @property {number} id - instance id: each instance is given a unique number when it is created * @property {string} index - unique instance index that is made up of a [component index]{@link ccm.types.component_index} and the instance id separated with a &lt;code&gt;-&lt;/code&gt; * @property {Element} root - root element that either contains the shadow root or directly the website area to be designed * @property {Element} [shadow] - shadow root inside the root element that contains the webpage area designed by the instance * @property {Element} [inner] - contains the Light DOM that was replaced by the Shadow DOM when the instance was created * @property {Element} element - webpage area designed by the instance * @property {Function} [init] - callback when the instance is created, all dependencies are solved and before dependent instances will be initialized (deleted after one-time call) * @property {Function} [ready] - callback when the instance is created and initialized and all dependent instances are initialized and ready (deleted after one-time call) * @property {Function} start - whenever the start method is called, the instance begins to design the webpage area assigned to it * @property {Function} [update] - Subsequently changes the value of a configuration property and defines how the instance reacts to it. Default reaction: Restart of the instance so that the website area is redesigned. */ /** * @typedef {Object} ccm.types.instance_config * @description * ... */ /** * @typedef {string} ccm.types.key * @description A string that is conform with the regular expression &lt;code&gt;/^[a-zA-Z0-9_-]+$/&lt;/code&gt;. * @example \"test\" * @example \"_foo\" * @example \"123\" * @example \"1-ABC-__123\" * @example \"_\" */ /** * @typedef {Object} ccm.types.resource_obj * @description Instead of an URL, a resource object can be passed to the method {@link ccm.load}, which then contains other information besides the URL, via which the loading of the resource is even more flexible controllable. * @property {string} url - URL from which the resource should be loaded * @property {Element} [context] - Context in which the resource should be loaded (default is &lt;code&gt;\\&lt;head&gt;&lt;/code&gt;). * @property {string} [type] - Resource is loaded as &lt;code&gt;'css'&lt;/code&gt;, &lt;code&gt;'html'&lt;/code&gt;, &lt;code&gt;'image'&lt;/code&gt;, &lt;code&gt;'js'&lt;/code&gt;, &lt;code&gt;'module'&lt;/code&gt;, &lt;code&gt;'json'&lt;/code&gt; or &lt;code&gt;'xml'&lt;/code&gt;. If not specified, the type is automatically recognized by the file extension. If the file extension is unknown, &lt;code&gt;'json'&lt;/code&gt; is used by default. * @property {string} [attr] - Additional HTML attributes to be set for the HTML tag that loads the resource. * @property {string} [method] - HTTP method to use: &lt;code&gt;'PUT'&lt;/code&gt;, &lt;code&gt;'GET'&lt;/code&gt;, &lt;code&gt;'POST'&lt;/code&gt;, &lt;code&gt;'DELETE'&lt;/code&gt;, &lt;code&gt;'JSONP'&lt;/code&gt; or &lt;code&gt;'fetch'&lt;/code&gt;. Default is &lt;code&gt;'POST'&lt;/code&gt;. Only relevant in case of a HTTP request. * @property {string} [params] - HTTP parameters to send in the case of a HTTP request. Only relevant in case of a HTTP request. * @property {string} [headers] - Additional HTTP headers to be set in the case of a HTTP Request. Only relevant in case of a HTTP request. * @property {Object} [init] - init object. Only relevant when using the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch). This is the second parameter that will be passed to the method &lt;code&gt;fetch&lt;/code&gt;. * @tutorial loading-of-resources */ /** * @typedef {string} ccm.types.version_index * @description A [version number]{@link ccm.types.version_nr} but separated with a &lt;code&gt;-&lt;/code&gt; instead of a &lt;code&gt;.&lt;/code&gt;. * @example '1-0-0' * @example '2-1-3' */ /** * @typedef {string} ccm.types.version_nr * @description A version number that is conform with Semantic Versioning 2.0.0 ({@link http://semver.org}). * @example '1.0.0' * @example '2.1.3' */ √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Namespaces Namespaces ccm helper types √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Tutorials Namespaces ccm helper types √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"index.html":{"id":"index.html","title":"Index","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components ccmjs Technology The \"Client-side Component Model\" (ccmjs) is a technology to expand the functionality of the web. Component developers can develop their own ccmjs-based web components and put them on the web as free software. Everyone can then use the components to design any webpage area. The functionality of a component can be adapted via its configuration and components can be combined to form larger applications. ccmjs also offers services for loading resources and data management. Index ccm.js Core script of ccmjs that is automatically loaded as soon as a component is integrated into a webpage. The core script sets an object in the namespace window.ccm that represents the loaded ccmjs version and defines the Custom Element &lt;ccm-app&gt;. Version: latest (26.0.0) Author: Andr√© Kless &lt;andre.kless@web.de&gt; 2014-2020 License: The MIT License (MIT) Source: ccm.js, line 1 Tutorials: Usage of Components √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"ccm.html":{"id":"ccm.html","title":"Namespace: ccm","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Namespace: ccm ccm Everything around ccmjs is capsuled in the single global namespace window.ccm. The namespace contains the latest version of ccmjs that has been loaded so far within the webpage. In the webpage a ccmjs version is represented as a JavaScript object. The object provides methods for using components, loading of resources and data management. For backwards compatibility each ccmjs version loaded on the webpage so far has its own inner namespace within window.ccm. This ensures that different versions of ccmjs can be used without conflict within the same webpage. Source: ccm.js, line 491 Namespaces helper types Members &lt;static&gt; callbacks :Object.&lt;string, function()&gt; JSONP callbacks for cross domain data exchanges via ccm.load are temporarily stored here (is always emptied directly). This global namespace ccm.callbacks is also used for dynamic loading of JavaScript modules. The namespace is only used internally by ccmjs and should not used by component developers. Type: Object.&lt;string, function()&gt; Source: ccm.js, line 467 Tutorials: Loading of Resources &lt;static&gt; components :Object Global namespace under which each registered component can provide public data and functions to the webpage under its unique component index. This namespace is helpful to see which component version is already registered in which ccmjs version within the webpage. The namespace is usually not used by component developers. Type: Object Source: ccm.js, line 1558 Tutorials: Usage of Components Example { 'chat-1-0-2': { valid: true }, 'quiz-1-0-0': { foo: 'bar', sayHello: name =&gt; console.log( 'Hello ' + name ) }, 'quiz-2-1-0': { n: 5711 } }; &lt;static&gt; files :Object Result data of loaded JavaScript files via ccm.load are temporarily stored here (is always emptied directly). The namespace is only used internally by ccmjs and should not used by component developers. Type: Object Source: ccm.js, line 477 Tutorials: Loading of Resources &lt;static&gt; timeout :number Timeout limit (in ms) for a resource loaded via ccm.load (default: no timeout). Type: number Source: ccm.js, line 2811 Tutorials: Loading of Resources Methods &lt;static&gt; component(component [, config]) registers a component Registers a component within this ccmjs version. The returned component object can than be used for flexible instance creation. This method can be used to define dependencies to other components in instance configurations. After registration, the component is ready to use on the webpage. If a URL to a component file is passed instead of a component object, the object is determined by loading this file. If the component uses a different ccmjs version, this version is loaded (if not already present) and then the component is registered in that ccmjs version instead. With the config parameter you can pass a default instance configuration that will be integrated with higher priority in the default instance configuration that is defined by the component. The resulting default configuration applies for all instances that are created via the returned component object. Parameters: Name Type Argument Description component ccm.types.component_obj | string component object or URL of a component file config ccm.types.instance_config &lt;optional&gt; default configuration for instances that are created out of the component (check documentation of associated component to see which properties could be set) Source: ccm.js, line 981 Tutorials: Usage of Components Returns: cloned component object (the original cannot be reached from the outside for security reasons) Type Promise.&lt;ccm.types.component_obj&gt; Examples const component_obj = await ccm.component( { name: 'blank', ccm: 'https://ccmjs.github.io/ccm/ccm.js', Instance: function () { this.start = async () =&gt; { this.element.innerHTML = 'Hello, World!'; }; } } ); const instance = await component_obj.instance( { root: document.body } ); await instance.start(); const component_obj = await ccm.component( 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js' ); const instance = await component_obj.instance( { root: document.body } ); await instance.start(); &lt;static&gt; get( [config] [, key_or_query]) reads a dataset of a datastore This method does the same as ccm.store with the difference that a dataset is directly read from the datastore. The dataset is returned as result. Use this method if you only read a dataset once and then need no further access to the datastore. This method can be used to define dependencies to other datasets in instance configurations. In order to read only a certain subset of a dataset, the dot notation can be used in the key_or_query parameter. Then the complete dataset is read but the result is only the requested subset. If a query is passed instead of a dataset key, several datasets can be loaded. Parameters: Name Type Argument Default Description config Object &lt;optional&gt; {} datastore accessor configuration key_or_query ccm.types.key | Object &lt;optional&gt; {} either a dataset key or a query to read several datasets (default: read all datasets) Source: ccm.js, line 1517 Tutorials: Data Management Returns: Type Promise.&lt;(ccm.types.dataset|Array.&lt;ccm.types.dataset&gt;)&gt; &lt;static&gt; instance(component [, config]) registers a component and creates an instance out of it This method does the same as ccm.component with the difference that an instance is created directly from the component after the registration. The created instance is returned as result. Whenever the start method of the instance is called, the instance begins to design the webpage area assigned to it. This method can be used to define dependencies to other instances in instance configurations. The given instance configuration will be integrated with higher priority in the default instance configuration that is defined by the component. Parameters: Name Type Argument Description component ccm.types.component_obj | string component object or URL of a component file config Object &lt;optional&gt; instance configuration (check documentation of associated component to see which properties could be set) Source: ccm.js, line 1101 Tutorials: Usage of Components Returns: Type Promise.&lt;ccm.types.instance&gt; Examples const instance = await ccm.instance( { name: 'blank', ccm: 'https://ccmjs.github.io/ccm/ccm.js', Instance: function () { this.start = async () =&gt; { this.element.innerHTML = 'Hello, World!'; }; } }, { root: document.body } ); await instance.start(); const instance = await ccm.instance( 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js', { root: document.body } ); await instance.start(); &lt;static&gt; load(resources) loads resources ccmjs provides a service for asynchronous loading of resources. It could be used with the method ccm.load. You can load resources like HTML, CSS, Images, JavaScript, Modules, JSON and XML data on-demand and cross-domain. On a single call several resources can be loaded at once. It can be flexibly controlled which resources are loaded in serial and which in parallel. See Loading of Resources to learn everything about this method. There are also more examples how to use it. This method can be used to define dependencies to other resources in instance configurations. Parameters: Name Type Argument Description resources string | ccm.types.resource_obj &lt;repeatable&gt; resources data Source: ccm.js, line 505 Tutorials: Loading of Resources Returns: Type Promise.&lt;*&gt; &lt;static&gt; start(component [, config]) registers a component, creates an instance out of it and starts the instance This method does the same as ccm.instance with the difference that the created instance is started directly. See Usage of Components to learn everything about ccmjs-based components and their instances. Parameters: Name Type Argument Description component ccm.types.component_obj | string component object or URL of a component file config Object &lt;optional&gt; instance configuration (check documentation of associated component to see which properties could be set) Source: ccm.js, line 1450 Tutorials: Usage of Components Returns: Type Promise.&lt;ccm.types.instance&gt; Examples const instance = await ccm.start( { name: 'blank', ccm: 'https://ccmjs.github.io/ccm/ccm.js', Instance: function () { this.start = async () =&gt; { this.element.innerHTML = 'Hello, World!'; }; } }, { root: document.body } ); const instance = await ccm.start( 'https://ccmjs.github.io/akless-components/blank/ccm.blank.js', { root: document.body } ); &lt;static&gt; store( [config]) provides access to a datastore ccmjs provides a service for data management. It could be used with this method. Use the methods get, set and del of the result object to create, read, update or delete datasets in the datastore. This method can be used to define dependencies to other datastores in instance configurations. Parameters: Name Type Argument Default Description config Object &lt;optional&gt; {} datastore accessor configuration Source: ccm.js, line 1467 Tutorials: Data Management Returns: datastore accessor Type Promise.&lt;ccm.types.datastore&gt; &lt;static&gt; version() Returns the ccmjs version. Source: ccm.js, line 1536 Returns: Type ccm.types.version_nr √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"ccm.helper.html":{"id":"ccm.helper.html","title":"Namespace: helper","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Namespace: helper ccm. helper Contains useful help methods that can be used by component developers. Source: ccm.js, line 1645 Methods &lt;static&gt; arrToStore(arr) converts an array of datasets to a collection of ccmjs datasets Parameters: Name Type Description arr Array.&lt;ccm.types.dataset&gt; array of datasets Source: ccm.js, line 1652 Returns: collection of ccmjs datasets Type ccm.types.datasets &lt;static&gt; clone(value) create a deep copy of a given value Parameters: Name Type Description value * given value Source: ccm.js, line 1670 Returns: deep copy of given value Type * &lt;static&gt; compareVersions(a, b) compares two version numbers (given as string) Version numbers must be conform with Semantic Versioning 2.0.0 (http://semver.org). Parameters: Name Type Description a string 1st version number b string 2nd version number Source: ccm.js, line 1699 Returns: -1: a &lt; b, 0: a = b, 1: a &gt; b Type number Example console.log( compareVersions( '8.0.1', '8.0.10' ) ); =&gt; -1 &lt;static&gt; convertComponentURL(url) extract data from the URL of a ccm component The result data contains the unique 'name', 'version' and 'index' of the component. The 'minified' flag is set if the filename contains a \".min\". Parameters: Name Type Description url string ccm component URL Source: ccm.js, line 1732 Throws: if component filename is not valid Type Error Returns: extracted data Type Object Examples const data = ccm.helper.convertComponentURL( './ccm.quiz-4.0.2.js' ); console.log( data ); // {\"name\":\"quiz\",\"version\":\"4.0.2\",\"index\":\"quiz-4-0-2\",\"url\":\"./ccm.quiz-4.0.2.js\"} const data = ccm.helper.convertComponentURL( './ccm.quiz.js' ); // latest version console.log( data ); // {\"name\":\"quiz\",\"index\":\"quiz\",\"url\":\"./ccm.quiz.js\"} const data = ccm.helper.convertComponentURL( './ccm.quiz.min.js' ); // minified console.log( data ); // {\"name\":\"quiz\",\"index\":\"quiz\",\"url\":\"./ccm.quiz.min.js\",\"minified\":true} &lt;static&gt; deepValue(obj, key [, value]) get or set the value of a deeper object property Parameters: Name Type Argument Description obj Object object that contains the deeper property key string key path to the deeper property in dot notation value * &lt;optional&gt; value that should be set for the deeper property Source: ccm.js, line 1780 Returns: value of the deeper property Type * Examples var obj = { test: 123, foo: { bar: 'abc', baz: 'xyz' } }; var result = ccm.helper.deepValue( obj, 'foo.bar' ); console.log( result ); // =&gt; 'abc' var obj = {}; var result = ccm.helper.deepValue( obj, 'foo.bar', 'abc' ); console.log( obj ); // =&gt; { foo: { bar: 'abc' } } console.log( result ); // =&gt; 'abc' &lt;static&gt; format(data [, values]) replaces placeholder in data with given values Parameters: Name Type Argument Description data * data with contained placeholders values * &lt;optional&gt; &lt;repeatable&gt; given values Source: ccm.js, line 1806 Returns: data with replaced placeholders Type * &lt;static&gt; generateConfig(element) generates an instance configuration out of a HTML element Parameters: Name Type Description element string | ccm.types.html | Array.&lt;ccm.types.html&gt; | Node | jQuery HTML element Source: ccm.js, line 1890 Returns: Type ccm.types.config &lt;static&gt; generateKey() generates a unique key An automatic generated unique key is made up of three parts. The first part is the current time in milliseconds. The second part is an 'X' as separator between first and last part. The last part is a random number. Source: ccm.js, line 2033 Returns: unique key Type ccm.types.key Example console.log( ccm.helper.generateKey() ); // 1465718738384X6869462723575014 &lt;static&gt; html(html [, values] [, settings]) transforms HTML to a HTML element and replaces placeholders (recursive) Parameters: Name Type Argument Description html string | ccm.types.html | Array.&lt;ccm.types.html&gt; | Node | jQuery | function values string | Object &lt;optional&gt; values to replace placeholder settings Object &lt;optional&gt; advanced settings Properties Name Type Argument Description no_evaluation boolean &lt;optional&gt; skips evaluation of ccm HTML elements namespace_uri string &lt;optional&gt; sets namespace URI for created elements Source: ccm.js, line 2048 Returns: HTML element Type Element | Array.&lt;Element&gt; &lt;static&gt; html2json(html) converts HTML to JSON Parameters: Name Type Description html string | jQuery | DocumentFragment | Element | ccm.types.html Source: ccm.js, line 2165 Returns: ccm HTML data Type ccm.types.html &lt;static&gt; integrate( [priodata] [, dataset] [, as_defaults]) integrates priority data into a given dataset Each value of each property in the given priority data will be set in the given dataset for the property of the same name. This method also supports dot notation in given priority data to set a single deeper property in the given dataset. With no given priority data, the result is the given dataset. With no given dataset, the result is the given priority data. Any data dependencies are resolved before integration. Parameters: Name Type Argument Description priodata Object &lt;optional&gt; priority data dataset Object &lt;optional&gt; dataset as_defaults boolean &lt;optional&gt; integrate values only if not already exist Source: ccm.js, line 2266 Returns: dataset with integrated priority data Type Object Examples const dataset = { firstname: 'John', lastname: 'Doe', fullname: 'John Doe' }; const priodata = { lastname: 'Done', fullname: undefined }; const result = await ccm.helper.integrate( priodata, dataset ); console.log( result ); // { firstname: 'John', lastname: 'Done', fullname: undefined }; const result = await ccm.helper.integrate( { 'foo.c': 'z' }, { foo: { a: 'x', b: 'y' } } ); console.log( result ); // { foo: { a: 'x', b: 'y', c: 'z' } } const result = await ccm.helper.integrate( { value: 'foo' } ); console.log( result ); // { value: 'foo' } const result = await ccm.helper.integrate( undefined, { value: 'foo' } ); console.log( result ); // { value: 'foo' } const store = { data: { key: 'data', foo: 'bar' } }; const result = await ccm.helper.integrate( { 'value.foo': 'baz' }, { value: [ 'ccm.get', { local: store }, 'data' ] } ); console.log( result ); // { value: { foo: 'baz' } } &lt;static&gt; isComponent(value) check value for ccmjs component Parameters: Name Type Description value * value to check Source: ccm.js, line 2306 Returns: Type boolean &lt;static&gt; isCore(value) checks if a value is a ccmjs ccmjs object Parameters: Name Type Description value * value to check Source: ccm.js, line 2378 Returns: Type boolean &lt;static&gt; isDataset(value) checks if a value is a ccm dataset Parameters: Name Type Description value * value to check Source: ccm.js, line 2317 Returns: Type boolean &lt;static&gt; isDatastore(value) checks if a value is a ccm datastore object Parameters: Name Type Description value * value to check Source: ccm.js, line 2324 Returns: Type boolean &lt;static&gt; isDependency(value) check value if it is a ccmjs dependency Parameters: Name Type Description value * Source: ccm.js, line 2340 Returns: Type boolean Examples [ ccm.load, ... ] [ ccm.component, ... ] [ ccm.instance, ... ] [ ccm.proxy, ... ] [ ccm.start, ... ] [ ccm.store, ... ] [ ccm.get, ... ] [ ccm.set, ... ] [ ccm.del, ... ] &lt;static&gt; isElement(value) check value for HTML element node Parameters: Name Type Description value * value to check Source: ccm.js, line 2366 Returns: Type boolean &lt;static&gt; isInstance(value) checks if a value is a ccmjs instance Parameters: Name Type Description value * value to check Source: ccm.js, line 2385 Returns: Type boolean &lt;static&gt; isKey(value) checks if a value is a valid ccm dataset key Parameters: Name Type Description value * value to check Source: ccm.js, line 2392 Returns: Type boolean &lt;static&gt; isNode(value) check value for HTML node Parameters: Name Type Description value * value to check Source: ccm.js, line 2415 Returns: Type boolean &lt;static&gt; isObject(value) check value if it is an object (including not null and not array) Parameters: Name Type Description value * value to check Source: ccm.js, line 2426 Returns: Type boolean &lt;static&gt; isProxy(value) checks if a value is an ccm proxy instance Parameters: Name Type Description value * value to check Source: ccm.js, line 2437 Returns: Type boolean &lt;static&gt; isSpecialObject(value) checks if a value is a special object: (Window Object, Node, ccmjs Object, ccm Instance, ccm Component Object, ccm Datastore, jQuery Object) Parameters: Name Type Description value * Source: ccm.js, line 2448 Returns: Type boolean &lt;static&gt; isSubset(obj, other) checks if an object is a subset of another object Parameters: Name Type Description obj Object object other Object another object Source: ccm.js, line 2480 Returns: Type boolean Example const obj = { name: 'John Doe', counter: 3, isValid: true, x: { y: 'z' }, // check of inner object 'values.1': 123, // check of deeper array value 'settings.title': 'Welcome!' // check of deeper object value }; const other = { name: 'John Doe', counter: 3, isValid: true, values: [ 'abc', 123, false ], settings: { title: 'Welcome!', year: 2017, greedy: true }, x: { y: 'z' }, onLoad: function () { console.log( 'Loading..' ); } }; const result = ccm.helper.isSubset( obj, other ); console.log( result ); // =&gt; true &lt;static&gt; loading( [instance]) returns a ccmjs loading icon Parameters: Name Type Argument Description instance Object &lt;optional&gt; ccmjs instance (for determining Shadow DOM) Source: ccm.js, line 2530 Returns: ccmjs loading icon Type Element Examples document.body.appendChild( loading() ) document.body.appendChild( loading( instance ) ) &lt;static&gt; loadVersion(url) loads a ccmjs version Parameters: Name Type Description url string | Object ccmjs version URL Source: ccm.js, line 2499 Returns: namespace of loaded ccmjs version Type Promise.&lt;Object&gt; &lt;static&gt; log(message) logs a ccm-specific message in the browser console Parameters: Name Type Description message * Source: ccm.js, line 2554 &lt;static&gt; parse(string [, reviver]) converts a JSON string to JSON and removes hidden characters Parameters: Name Type Argument Description string string JSON string reviver function &lt;optional&gt; Source: ccm.js, line 2562 Returns: JSON Type * &lt;static&gt; regex(index) get a ccmjs relevant regular expression Possible index values, it's meanings and it's associated regular expressions: index meaning regular expression 'filename' filename for an _ccmjs_ instance /^(ccm.)?([^.-]+)(-(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*))?(\\.min)?(\\.js)$/ 'key' key for a _ccmjs_ dataset /^[a-z_0-9][a-zA-Z_0-9]*$/ Parameters: Name Type Description index string index of the regular expression Source: ccm.js, line 2608 Returns: RegExp Object Type RegExp Examples // test if a given string is a valid filename for an ccm component var string = 'ccm.dummy-3.2.1.min.js'; var result = ccm.helper.regex( 'filename' ).test( string ); console.log( result ); // =&gt; true // test if a given string is a valid key for a ccm dataset var string = 'dummy12_Foo3'; var result = ccm.helper.regex( 'key' ).test( string ); console.log( result ); // =&gt; true &lt;static&gt; responsive(element [, breakpoints] [, instance]) sets observed responsive breakpoints for an element Parameters: Name Type Argument Default Description element Element breakpoints Object &lt;optional&gt; { SM: 384, MD: 576, LG: 768, XL: 960 } instance Object &lt;optional&gt; ccm instance with an 'onbreakpoint' callback Source: ccm.js, line 2624 &lt;static&gt; solveDependencies(obj [, instance]) solves ccm dependencies contained in an object or array Parameters: Name Type Argument Description obj Object | Array object or array instance ccm.types.instance &lt;optional&gt; associated ccm instance Source: ccm.js, line 2654 Returns: Type Promise &lt;static&gt; solveDependency(dependency [, instance]) solves a ccm dependency Parameters: Name Type Argument Description dependency Array ccm dependency instance ccm.types.instance &lt;optional&gt; associated ccm instance Source: ccm.js, line 2690 Returns: Type Promise &lt;static&gt; solveDotNotation(obj) transforms a flat object which has dot notation in it's keys as path to deeper properties to an object with deeper structure (not yet uses in ccmjs) Parameters: Name Type Description obj Object Source: ccm.js, line 2745 Returns: Type Object &lt;static&gt; stringify(value [, replacer] [, space]) converts a value to a JSON string and removes not JSON valid data Parameters: Name Type Argument Description value * replacer function &lt;optional&gt; space string | number &lt;optional&gt; Source: ccm.js, line 2764 Returns: JSON string Type string &lt;static&gt; toDotNotation(obj [, all_levels]) transforms an object with deeper structure to a flat object with dot notation in each key as path to deeper properties Parameters: Name Type Argument Description obj Object object all_levels boolean &lt;optional&gt; result contains all levels of dot notation Source: ccm.js, line 2776 Returns: Type Object &lt;static&gt; toJSON(value) converts a value to valid JSON (removes not JSON valid data like functions, special objects and hidden characters) Parameters: Name Type Description value * Source: ccm.js, line 2802 Returns: valid JSON Type * √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"ccm.types.html":{"id":"ccm.types.html","title":"Namespace: types","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Namespace: types ccm. types ccmjs-specific type definitions Source: ccm.js, line 3014 Type Definitions component_index Each ccmjs component has an unique component index that is made up of a component name and a version index separated with a -. Type: string Source: ccm.js, line 3019 Examples 'blank-1-0-0' 'chat-2-1-3' 'blank' // no version number means latest version 'chat' component_name Each ccm component has an unique component name. The name must be conform with the regular expression /^[a-z][a-z_0-9]*$/. Type: string Source: ccm.js, line 3028 Examples 'blank' 'chat' 'my_blank' 'chat2' 'bank_001' component_obj A component is represented as a JavaScript object within ccmjs. Below you see the typically properties. name, version, config, Instance and ready are set by the component developer. ccm, index, instance, start and instances are set by ccmjs during registration. The component developer may set additional individual properties. Type: Object Properties: Name Type Argument Description ccm ccm ccmjs object used by the component name ccm.types.component_name component name version ccm.types.version_nr &lt;optional&gt; component version index ccm.types.component_index component index config Object &lt;optional&gt; default configuration for created instances ready function &lt;optional&gt; callback when this component is registered (deleted after one-time call) instance function creates an instance out of this component start function creates and starts an instance Instance function construction plan for instances that can be created out of the component instances number number of created instances (is only used internally to generate instance IDs) Source: ccm.js, line 3038 Example { ccm: {...}, name: 'chat', version: [ 2, 1, 3 ], index: 'chat-2-1-3', config: {...}, ready: async () =&gt; {...}, instance: config =&gt; {...}, start: config =&gt; {...}, Instance: function () {...}, instances: 0 } dataset JSON representation of a dataset that is managed via the ccmjs service for data management. Every dataset has a property key which contains the unique dataset key of the dataset. The _ property is reserved for permission settings. Type: Object Source: ccm.js, line 3069 Example { \"key\": \"demo\", \"text\": \"Hello, World!\", \"value\": 12, \"_\": { \"creator\": \"akless\", \"realm\": \"guest\", \"access\": \"creator\" } } dataset_key Each dataset that is managed via the ccmjs service for data management has an unique key. Array keys are also supported. An array will be internal converted to a string with .join(','). Type: ccm.types.key | Array.&lt;ccm.types.key&gt; Source: ccm.js, line 3087 Examples \"test\" \"_foo\" \"123\" \"1-ABC-__123\" \"_\" [ \"test\", \"_foo\", \"123\" ] // =&gt; \"test,_foo,123\" [ \"1-ABC-__123\", \"_\" ] // =&gt; \"1-ABC-__123,_\" html_data In ccmjs, loaded HTML is automatically converted into a JSON structure. This is than called HTML data. ... Type: Object Source: ccm.js, line 3101 instance An object created out of a ccmjs component. Below you see the typically properties. The component developer may set additional individual properties. Type: Object Properties: Name Type Argument Description ccm ccm ccmjs object used by the instance component ccm.types.component_obj component object from which the instance was created parent ccm.types.instance &lt;optional&gt; parent instance that has a dependency on this instance children Object.&lt;string, ccm.types.instance&gt; children instances which depend on this instance config string stringified configuration with which the component was created id number instance id: each instance is given a unique number when it is created index string unique instance index that is made up of a component index and the instance id separated with a - root Element root element that either contains the shadow root or directly the website area to be designed shadow Element &lt;optional&gt; shadow root inside the root element that contains the webpage area designed by the instance inner Element &lt;optional&gt; contains the Light DOM that was replaced by the Shadow DOM when the instance was created element Element webpage area designed by the instance init function &lt;optional&gt; callback when the instance is created, all dependencies are solved and before dependent instances will be initialized (deleted after one-time call) ready function &lt;optional&gt; callback when the instance is created and initialized and all dependent instances are initialized and ready (deleted after one-time call) start function whenever the start method is called, the instance begins to design the webpage area assigned to it update function &lt;optional&gt; Subsequently changes the value of a configuration property and defines how the instance reacts to it. Default reaction: Restart of the instance so that the website area is redesigned. Source: ccm.js, line 3108 instance_config ... Type: Object Source: ccm.js, line 3130 key A string that is conform with the regular expression /^[a-zA-Z0-9_-]+$/. Type: string Source: ccm.js, line 3136 Examples \"test\" \"_foo\" \"123\" \"1-ABC-__123\" \"_\" resource_obj Instead of an URL, a resource object can be passed to the method ccm.load, which then contains other information besides the URL, via which the loading of the resource is even more flexible controllable. Type: Object Properties: Name Type Argument Description url string URL from which the resource should be loaded context Element &lt;optional&gt; Context in which the resource should be loaded (default is &lt;head&gt;). type string &lt;optional&gt; Resource is loaded as 'css', 'html', 'image', 'js', 'module', 'json' or 'xml'. If not specified, the type is automatically recognized by the file extension. If the file extension is unknown, 'json' is used by default. attr string &lt;optional&gt; Additional HTML attributes to be set for the HTML tag that loads the resource. method string &lt;optional&gt; HTTP method to use: 'PUT', 'GET', 'POST', 'DELETE', 'JSONP' or 'fetch'. Default is 'POST'. Only relevant in case of a HTTP request. params string &lt;optional&gt; HTTP parameters to send in the case of a HTTP request. Only relevant in case of a HTTP request. headers string &lt;optional&gt; Additional HTTP headers to be set in the case of a HTTP Request. Only relevant in case of a HTTP request. init Object &lt;optional&gt; init object. Only relevant when using the Fetch API. This is the second parameter that will be passed to the method fetch. Source: ccm.js, line 3146 Tutorials: Loading of Resources version_index A version number but separated with a - instead of a .. Type: string Source: ccm.js, line 3160 Examples '1-0-0' '2-1-3' version_nr A version number that is conform with Semantic Versioning 2.0.0 (http://semver.org). Type: string Source: ccm.js, line 3167 Examples '1.0.0' '2.1.3' √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-backwards-compatibility.html":{"id":"tutorial-backwards-compatibility.html","title":"Tutorial: Backwards Compatibility","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Backwards Compatibility √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-data-management.html":{"id":"tutorial-data-management.html","title":"Tutorial: Data Management","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Data Management Table Of Contents Introduction Choosable Data Levels Data Level 1: JavaScript Object Data Level 2: IndexedDB Data Level 3: Server-side Database Dataset Properties Usage Example Supported Operations Synchron vs. Asynchron Data Caching Server Interface Usable Network Protocols Real-time Communication Introduction The ccm framework provides a service for component developer for flexible data management. The service could be used with the method ccm.store. This method allows the usage of ccm datastores. A ccm datastore can manage datasets in one of three choosable data levels and could also be used autonomously of ccm components for easy data management. Choosable Data Levels Data Level 1: JavaScript Object On the first level the data will be managed in an local JavaScript object. Than all managed datasets are fugitive data which are gone when webpage is reloaded. Data Level 2: IndexedDB On the second level the data will be managed in the clientside database IndexedDB. Than all managed data is still there after page reload. This is specially interesting for offline functionality. Data Level 3: Server-side Database On the third level the data will be managed in any server-side database of choice. The server must have an ccm compatible interface. Than all managed datasets are stored persistent on a server and they are not bounded to a specific client. Different network protocols are possible for communication between client and server. The following image shows an overview about ccm data management: Dataset Properties Every managed dataset must have a property key which contains the unique key of the dataset. There are no conventions for other properties. They can be as they want. The following code shows an example for a ccm dataset: { \"key\": \"quizz\", \"question\": \"What is the meaning of life?\", \"answers\": [ \"nothing\", \"don't know\", \"ccm programming\", \"other things\" ], \"type\": \"multiple_choice\" } Usage Example The following code shows an first simple example for working with a ccm datastore: // create a empty datastore of data level 1 var store = ccm.store(); // store new dataset with unique key 'test' in created datastore var created_dataset = store.set( { key: 'test', value: 4711 } ); // get stored dataset var requested_dataset = store.get( 'test' ); // update stored dataset var updated_dataset = store.set( { key: 'test', value: 'foo' } ); // delete stored dataset var deleted_dataset = store.del( 'test' ); For more detail how to use the method ccm.store see the documentation of the method. Supported Operations A ccm datastore supports the following operation: Operation Description get(key) Get a single dataset with the given key. get(query) Get all datasets that matches the given query. set(data) Create a new dataset that contains the given data. set(prio) Updates a existing dataset with given priority data. del(key) Delete a existing dataset with given key. For more details how to use these operations see the part for ccm datastores in the API of the ccm framework. Here you see which data level supports which operations: Operation L1: JavaScript Object L2: IndexedDB L3: Redis L3: MongoDB get(key) supported supported supported supported get(query) supported - - supported* set(data) supported supported supported supported set(prio) supported supported supported** supported*** del(key) supported supported supported supported * all specific MongoDB queries are possible ** no partial update (updates always complete dataset) *** support deep partial updates (with dot notation) Note that on data level 3 the server not only can have Redis and MongoDB as database. This are only common examples. For example the server-side database must not be an NoSQL database. Which of the operations other databases support depends mainly on the server interface. Synchron vs. Asynchron Each of the datastore operations has a callback as second parameter. The result of an operation will be provided to the callback function as first parameter. If the operation don't causes any asynchron operation, the result will be also provided as return value. Operations on data level 1 are synchron and operations on higher data levels are asynchron. No matter of synchron or asynchron, in case of doubt use the callback function to collect the requested dataset(s). Using callbacks gives also the possibility to switch anytime to another data level without code changes. The following example shows collecting the result of an ccm datastore operation in both ways: var store = ccm.store(); var synchron_result = store.get( function ( asynchron_result ) { console.log( asynchron_result ); } ); console.log( synchron_result ); Data Caching On data level 1 the data will be managed in an local JavaScript object. On higher data levels this object acts as a local cache. Then all results of every datastore operation are local cached. When requesting datasets that are already cached, the datasets are taken from there. This results in a shorter execution time. Another effect is that requests for already cached datasets are synchron and the result can received directly as return value of the method call: // provides a datastore of data level 2 var store = ccm.store( { store: 'my_store' } ); // The first request for the dataset is asynchron and the result store.get( 'test', function () { // dataset is now local cached. // The second dataset request is synchron and the result is receivable var result = store.get( 'test' ); // as return value of the method call. } ); Server Interface When a client uses a ccm datastore of data level 3 for data management, than the client must declare an URL to an ccm compatible server interface in the datastore settings. Then all datastore operations will be forwarded to this server interface. The server interface then can forward this operations to the server-side database. In this step the server interface must transform the according data in the form which the specific database can handle. Then the server interface sends the results back to the client in the form the client-side datastore can receive them. The following example shows a very simple dummy server interface in PHP which receives the forwarded datastore operations and send them back to client without forwarding to a database: &lt;?php // receive datastore operation $key = $_GET[ 'key' ]; // get $dataset = $_GET[ 'dataset' ]; // set (create or update) $del = $_GET[ 'del' ]; // del // send dummy response back to client if ( $key ) die( array( 'key' =&gt; $key, 'value' =&gt; 'foo' ) ); // get if ( $dataset ) { $dataset[ 'value' ] = 'bar'; die( $dataset ); } // set if ( $del ) die( array( 'key' =&gt; $del, 'value' =&gt; 'baz' ) ); // del ?&gt; The server interface must not be written in PHP. For example it can also be written in JavaScript (with Node.js). An better professional server interface should think of the following aspects: Cross-domain data transmissions with CORS or JSONP Support of different network protocols Security mechanisms for user authentication user rights for data operations secure network protocols More than one choosable database Support of stable and efficient realtime communication Server stability, availability and scalability Usable Network Protocols Different network protocols could be used for data transmission between client and server depending on the supported network protocols of the server interface. For example an server interface could support some of the following protocols: Hypertext Transfer Protocol (HTTP) Hypertext Transfer Protocol Secure (HTTPS) WebSocket (WS) WebSocket Secure (WSS) To choose on client-side which supported network protocol should be used, simple use the corresponding prefix in the URL to the server interface in the datastore settings. For example: http://path/to/server/interface.php https://path/to/server/interface.php ws://path/to/server/interface.php wss://path/to/server/interface.php Real-time Communication In case of realtime communication with Web Socket as network protocol for a ccm datastore with data level 3, the server informs every active client about changing datasets. To react to this informations on client-side there only must be declared a onChange callback for the datastore. The parameters of the callback contain the server informations about the changed dataset. The following code shows an example for declaring a onChange callback: ccm.store( { store: 'my_store', url: 'http://path/to/server/interface.php', onChange: function () { console.log( arguments ); // Shows the server informations about changed } // stored datasets in the developer console. } ); Note that changing a dataset not triggers the own onChange event. The server informs only other clients about changed data. Open the same website in a second browser tab to trigger the event. √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-html-templating.html":{"id":"tutorial-html-templating.html","title":"Tutorial: HTML Templating","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components HTML Templating √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-instance-communication.html":{"id":"tutorial-instance-communication.html","title":"Tutorial: Instance Communication","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Instance Communication √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-loading-of-resources.html":{"id":"tutorial-loading-of-resources.html","title":"Tutorial: Loading of Resources","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Loading of Resources Overview ccmjs provides a service for asynchronous loading of resources. It could be used with the method ccm.load. You can load resources like HTML, CSS, Images, JavaScript, Modules, JSON and XML data on-demand and cross-domain. On a single call several resources can be loaded at once. It can be flexibly controlled which resources are load in serial and which in parallel. ccm.load can be used in an instance configuration to define dependencies to other resources. Simplest Case: Loading by URL In the simplest case, only an URL is passed as a parameter for a resource to be loaded: ccm.load( 'style.css' ); The URL of the resource can be a relative or an absolute path. The resource does not have to be within the same domain and can be loaded cross-domain. Loading by Object Instead of an URL, a resource object can be passed, which then contains other information besides the URL, via which the loading of the resource is even more flexible controllable. For example, when loading a resource, it can be specified in which context it is loaded. With this, the CSS contained in a CSS file can be loaded into a specific Shadow DOM: const shadow = document.createElement( 'div' ); shadow.attachShadow( { mode: 'open' } ); ccm.load( { url: 'style.css', context: shadow } ); Method Result The method ccm.load is an asynchronous function and returns a Promise that provides the result. The following example loads the content of an HTML file: // Promise ccm.load( 'hello.html' ).then( result =&gt; {} ); // async await const result = await ccm.load( 'hello.html' ); &lt;!-- hello.html --&gt; Hello, &lt;b&gt;World&lt;/b&gt;! The variable result now contains the HTML string \"Hello, &lt;b&gt;World&lt;/b&gt;!\". Error Handling If loading of a resource fails, the resulting Promise will be rejected: // Promise ccm.load( 'not_exits.html' ).catch( error =&gt; {} ); // async await try { await ccm.load( 'not_exists.html' ); } catch ( error ) {} The variable error then contains an object with informations about the error. The following table shows what information this object contains: Property Value call Action data of the original method call. data Object of the XMLHttpRequest. error Error object of the failed XMLHttpRequest. resource Passed resource object. In case of a XMLHttpRequest the HTTP status code and the response text can be checked via data and with error you can get the responded error message: try { await ccm.load( 'not_available.html' ); } catch ( error ) { if ( error.data.status === 404 ) // not found? alert( error.error.message ); // =&gt; show error message of XMLHttpRequest else if ( error.data.responseText ) // error with response text? alert( error.data.responseText ); // =&gt; show response text else alert( 'Something went wrong' ); } Watch the error variable in the developer console to see what other useful data is included. Loading with Timeout For loading resources, a timeout can be set: ccm.timeout = 10000; // timeout after 10 seconds In this example, resources that last longer than 10 seconds would fail. By default, there is no time limit. If a result is received after the timeout has expired, a message like this appears in the developer console: [ccmjs] loading of https://my.domain/bigdata.php succeeded after timeout (10000ms) Loading of Multiple Resources at Once On a single ccm.load call several resources can be loaded at once: const results = await ccm.load( 'hello.html', 'style.css', 'image.png' ); When multiple resources are loaded, the Promise provides an array instead of a single value as the result. The array contains the results in the order in which the parameters were passed. If loading a resource does not supply anything specific, the default result is the URL of the resource. This applies, for example, when loading CSS and images. The variable results now contains: [ \"Hello, &lt;b&gt;World&lt;/b&gt;!\", \"style.css\", \"image.png\" ] If loading of at least one of the resources fails, the result is still an array. For failed resources, the array will contain the error object instead of the result: try { await ccm.load( 'not_exists.html', 'style.css', 'image.png' ); } catch ( error ) { console.log( error ); // [ {error object}, \"style.css\", \"image.png\" ] } Parallel and Serial Loading of Resources It can be flexibly controlled which resources are loaded serially and which ones in parallel. By default, resources are loaded in parallel. When resources are to be loaded one after another, they simply need to be passed as an array: ccm.load( [ 'hello.html', 'style.css' ] ); In the example, the two resources are now loaded serially. The serial and parallel loading can be flexibly controlled as deep as desired. With each deeper array level you switch between serial and parallel loading: ccm.load( 'hello.html', // Array Level 0: Parallel [ 'style.css', // Array Level 1: Serial 'image.png', [ 'data.json', // Array Level 2: Parallel 'script.mjs' ], 'logo.gif' ], 'picture.jpg' ); The example loads the resources in the following timeline: Resource Timeline hello.html ******------------------ style.css ******------------------ image.png ------******------------ data.json ------------******------ script.mjs ------------******------ logo.gif ------------------****** picture.jpg ******------------------ Loading of HTML Loading an HTML file results in a string that contains the content of the loaded HTML file: &lt;!-- hello.html --&gt; Hello, World! const result = await ccm.load( 'hello.html' ); The variable result now contains the HTML string \"Hello, &lt;b&gt;World&lt;/b&gt;!\". An HTML string can be converted into an HTML element with the help method ccm.helper.html and with ccm.helper.html2json you can transform an HTML string to JSON. An HTML file can contain multiple HTML templates. Each template must then be wrapped with &lt;ccm-template key=\"mykey\"&gt;, where mykey is a unique key for the template: &lt;!-- templates.html --&gt; &lt;ccm-template key=\"main\"&gt; &lt;header&gt;...&lt;/header&gt; ... &lt;footer&gt;...&lt;/footer&gt; &lt;/ccm-template&gt; &lt;ccm-template key=\"entry\"&gt; &lt;h3&gt;...&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; &lt;/ccm-template&gt; const result = await ccm.load( 'templates.html' ); The variable result then contains an object with the loaded HTML templates: { \"main\": \" &lt;header&gt;...&lt;/header&gt; ... &lt;footer&gt;...&lt;/footer&gt; \", \"entry\": \" &lt;h3&gt;...&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; \" } Loading of CSS CSS is loaded by adding a &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"url\"&gt; in the DOM, where url is the URL of the CSS file. Use the context property of a resource object to control in which element the &lt;link&gt; tag will be appended. With this, the CSS contained in a CSS file can be loaded into a Shadow DOM: const shadow = document.createElement( 'div' ); shadow.attachShadow( { mode: 'open' } ); await ccm.load( { url: 'style.css', context: shadow } ); By default, the CSS is loaded in the &lt;head&gt; of the webpage: await ccm.load( 'style.css' ); &lt;head&gt; ... &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; &lt;/head&gt; With the attr property of a resource object you can add additional HTML attributes to the &lt;link&gt; tag. For example this allows you to load CSS with Subresource Integrity: await ccm.load( { url: 'style.css', attr: { integrity: 'sha384-TNlMHgEvh4ObcFIulNi29adH0Fz/RRputWGgEk/ZbfIzua6sHbLCReq+SZ4nfISA', crossorigin: 'anonymous' } } ); &lt;head&gt; ... &lt;link rel=\"stylesheet\" href=\"style.css\" integrity=\"sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z\" crossorigin=\"anonymous\"&gt; &lt;/head&gt; Loading of a CSS resolves, when the onload event of the &lt;link&gt; tag fires. When the exact same &lt;link&gt; tag is already present in the context, then loading of CSS succeeds without appending the same &lt;link&gt; tag again, because the CSS seems to be already loaded in this context. The result value is the URL of the CSS file. Loading of Images The method ccm.load can be used for preloading images: ccm.load( 'image1.png', 'image2.jpg', 'image3.gif' ); In the example the three images are loaded in parallel and are than in the browser cache. Loading of an image resolves, when the onload event of the intern created image object fires. The result value is the URL of the image file. Loading of JavaScript Loading a JavaScript file will execute the JavaScript code contained in the file. The JavaScript is loaded by adding a &lt;script src=\"url\" async&gt; in the DOM, where url is the URL of the JavaScript file. Loading of JavaScript resolves, when the onload event of the &lt;script&gt; tag fires. After the JavaScript code has executed, the no more needed &lt;script&gt; tag will be removed from the DOM. The result value is the URL of the JavaScript file, but the loaded JavaScript code can also set the result individually: /* script.mjs */ ccm.files[ 'script.mjs' ] = { foo: 'bar' }; const result = await ccm.load( 'script.mjs' ); console.log( result ); // =&gt; { \"foo\": \"bar\" } The result value of a loaded JavaScript file is what the contained JavaScript code puts in ccm.files[ 'filename' ], where filename is the filename of the JavaScript file. Otherwise, the result is the URL of the file as usual. Using this convention, a JavaScript file can provide data across domains. The publicly fetched data in the global namespace ccm.files will be directly deleted. In case of a minimized JavaScript file, the .min in the filename can be omitted: /* script.min.js */ ccm.files['script.mjs']={foo:'bar'}; const result = await ccm.load( 'script.min.js' ); console.log( result ); // =&gt; { \"foo\": \"bar\" } With the attr property of a resource object you can add additional HTML attributes to the &lt;script&gt; tag. For example this allows you to load JavaScript with Subresource Integrity: await ccm.load( { url: 'script.mjs', attr: { integrity: 'sha384-QoLtnRwWkKw2xXw4o/pmW2Z1Zwst5f16sRMbRfP/Ova1nnEN6t2xUwiLOZ7pbbDW', crossorigin: 'anonymous' } } ); // &lt;script src=\"script.mjs\" async integrity=\"sha384-QoLtnRwWkKw2xXw4o/pmW2Z1Zwst5f16sRMbRfP/Ova1nnEN6t2xUwiLOZ7pbbDW\" crossorigin=\"anonymous\"&gt; Loading of Modules Loading a module gives you an object as result that contains all the exported members of the module: /* module.mjs */ export const name = 'John'; export const data = { foo: 'bar' }; export function sayHello( name ) { console.log( `Hello, ${name}!` ); } const result = await ccm.load( 'module.mjs' ); result.sayHello( result.name ); // =&gt; 'Hello, John!' console.log( result.data ); // =&gt; {\"foo\":\"bar\"} In the example result now contains all exported members of the module. An import * as result from 'url' is executed internally, where result is the result object and url is the URL of the module file. It is also possible to get a specific exported member only as result: const sayHello = await ccm.load( 'module.mjs#sayHello' ); sayHello( 'Jane' ); // =&gt; 'Hello, Jane!' Then intern an import {key} as result from 'url' is executed, where key is the name of the specific member. The member name can be set at the end of the URL after a #. This allows the definition of dependencies to a certain function within an instance configuration: const config = { sayHello: [ 'ccm.load', 'module.mjs#sayHello' ] } You can also get a specific subset of exported members. For this, several member names can be specified at the end of the URL separated by a #: const subset = await ccm.load( 'module.mjs#data#name' ); console.log( subset ); // =&gt; {\"data\":{\"foo\":\"bar\"},\"name\":\"John\"} Just like loading JavaScript, with the attr property of a resource object you can add additional HTML attributes to the &lt;script&gt; tag. Loading of JSON Data In the following example JSON data is load from a server interface: const result = await ccm.load( 'hello.php' ); console.log( result ); // =&gt; \"Hello, World!\" /* hello.php */ &lt;?php echo 'Hello, World!'; ?&gt; As default, the JSON data is load by XMLHttpRequest with the HTTP method POST. Loading of JSON cross-domain works only if CORS or JSONP is working. Individual HTTP parameters can be set with the params property of a resource object: const result = await ccm.load( { url: 'echo.php', params: { // sets HTTP parameters name: 'John' } } ); console.log( result ); // =&gt; \"Hello, John!\" /* echo.php */ &lt;?php echo 'Hello, '.filter_input( INPUT_POST, 'name', FILTER_SANITIZE_STRING ); ?&gt; The used HTTP method can be set by the method property: const result = await ccm.load( { url: 'hello.php', method: 'GET' // sets HTTP method } ); With the headers property, you can set additional HTTP headers: const result = await ccm.load( { url: 'hello.php', headers: { // sets additional HTTP headers Authorization: 'Basic ' + btoa( user + ':' + token ) } } ); JSON data can also be loaded via JSONP if the server side supports it: const result = await ccm.load( { url: 'https://other.domain.com/data.php', method: 'JSONP' // turns on JSONP } ); console.log( result ); // =&gt; {\"foo\":\"bar\"} /* data.php */ &lt;?php $callback = filter_input( INPUT_GET, 'callback', FILTER_SANITIZE_STRING ); echo $callback.'({\"foo\":\"bar\"});'; ?&gt; With JSONP the JSON data is load via &lt;script&gt; tag. So just like loading JavaScript, with the attr property of a resource object you can add additional HTML attributes to the &lt;script&gt; tag. JSONP is only necessary if the data has to be loaded cross-domain. JSONP is not required if CORS is already working. Another option is to let ccm.load use the fetch API. The second parameter of fetch(url,init) can be passed via the init property of a resource object: const result = await ccm.load( { url: 'https://other.domain.com/data.php', method: 'fetch', // uses fetch API init: { method: 'POST', mode: 'cors', cache: 'no-cache', credentials: 'same-origin', headers: { 'Content-Type': 'application/json' }, redirect: 'follow', referrerPolicy: 'no-referrer' } } ); console.log( result ); // =&gt; {\"foo\":\"bar\"} This allows you to use the full power of the fetch API in resource dependencies: const config = { sayHello: [ 'ccm.load', { url: 'sayHello.php', method: 'fetch', init: {...} } ] } Loading of XML Data The following example loads an XML file: const result = await ccm.load( 'data.xml' ); console.log( result ); // =&gt; #document The result variable than contains a XMLDocument containing the loaded XML. Loading of XML cross-domain works only if CORS is working. Loading a Resource Regardless of its File Extension Normally ccm.load automatically recognizes at the file extension how the resource should be loaded. When the type property of a resource object is specified, the file extension of the resource is ignored and the resource is loaded as the specified type. If type is not specified and the file extension is unknown, loading of JSON is assumed. This allows you the dynamic loading of resources. Dynamic Loading of CSS The following example loads CSS from a PHP interface: ccm.load( { url: 'style.php', type: 'css' } ); /* style.php */ &lt;?php header( 'Content-Type: text/css' ); ?&gt; b { color: red; } Although the resource does not have the file extension .css, it will be loaded like a CSS file. The &lt;head&gt; now contains: &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.php\"&gt;. Dynamic Loading of an Image This example preloads an image that comes from a PHP interface: ccm.load( { url: 'image.php', type: 'image' } ); &lt;?php header( 'Content-Type: image/png' ); readfile( 'intern/image.png' ); ?&gt; If the PHP interface would additionally implement user authentication, images could be made available to specific user groups. An HTTP parameter could also be used to control which image should be delivered. Dynamic Loading of JavaScript In this example JavaScript is load from a PHP interface: const result = await ccm.load( { url: 'script.php', type: 'js' } ); /* js.php */ ccm.files[ 'js.php' ] = { foo: '&lt;? echo 'bar'; ?&gt;' }; console.log( 'Hello, &lt;? echo 'World'; ?&gt;!' ); The &lt;head&gt; now contains: &lt;script src=\"script.php\"&gt;. Result in the Developer Console: Hello, World! Result of the resolved Promise: {\"foo\":\"bar\"} Other Aspects A resource object passed to ccm.load is cloned to prevent external manipulations. In a resource object, the reference to an instance can also be passed for the property context. The resource is then loaded into the Shadow DOM of the instance. When a resource is loaded into a specific context, care must be taken that this context has DOM contact. The chosen context should not be an on-the-fly element or part of it. This is required so that the HTML element used to load the resource is evaluated by the browser. √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "},"tutorial-usage-of-components.html":{"id":"tutorial-usage-of-components.html","title":"Tutorial: Usage of Components","body":" ccmjs Namespaces ccmccm.helperccm.types Tutorials Backwards CompatibilityData ManagementHTML TemplatingInstance CommunicationLoading of ResourcesUsage of Components Usage of Components √ó Search results Close This Documentation is written by the Developer of ccmjs: Andr√© Kless "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
